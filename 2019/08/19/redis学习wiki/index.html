<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.jpg?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.jpg?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>


<!-- google 广告   http://www.google.com/adsense -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
	<script>
	     (adsbygoogle = window.adsbygoogle || []).push({
	          google_ad_client: "ca-pub-8966265724665848",
	          enable_page_level_ads: true
	     });
	</script>

  <meta name="description" content="第一天了解redis的数据库，了解相似的缓存数据库，redis的局限redis数据库 非关系型数据库  以键(key)和值(value)做映射(mapping) value类型：  string：字符串对象 list：列表对象 hash：哈希对象 set：集合对象 zset：有序集合对象   类型(前缀：REDIS)编码(前缀：REDIS_ENCODING)对象结构的读写能力STRINGINT(l">
<meta name="keywords" content="学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="redis学习wiki">
<meta property="og:url" content="https://jijiking51.cn/2019/08/19/redis学习wiki/index.html">
<meta property="og:site_name" content="RocWong">
<meta property="og:description" content="第一天了解redis的数据库，了解相似的缓存数据库，redis的局限redis数据库 非关系型数据库  以键(key)和值(value)做映射(mapping) value类型：  string：字符串对象 list：列表对象 hash：哈希对象 set：集合对象 zset：有序集合对象   类型(前缀：REDIS)编码(前缀：REDIS_ENCODING)对象结构的读写能力STRINGINT(l">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-08-25T04:09:19.927Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="redis学习wiki">
<meta name="twitter:description" content="第一天了解redis的数据库，了解相似的缓存数据库，redis的局限redis数据库 非关系型数据库  以键(key)和值(value)做映射(mapping) value类型：  string：字符串对象 list：列表对象 hash：哈希对象 set：集合对象 zset：有序集合对象   类型(前缀：REDIS)编码(前缀：REDIS_ENCODING)对象结构的读写能力STRINGINT(l">
  <link rel="canonical" href="https://jijiking51.cn/2019/08/19/redis学习wiki/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>redis学习wiki | RocWong</title>
  <meta name="generator" content="Hexo 3.8.0">
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e30f4d88f73cfa8c61f49d129ee6ced8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-right">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RocWong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">19</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">13</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">28</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    
  <div class="popup search-popup">
  <div class="search-header">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <div class="search-input-wrapper">
      <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input">
    </div>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>
  <div id="search-result"></div>
</div>


  </div>
</div>
    </header>

    

  <a href="https://github.com/BirdWong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><a href="https://github.com/birdwong/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

    <!-- 复制转载提示 -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/sweetalert/1.1.3/sweetalert.min.css">
    <script type="text/javascript" src="https://cdn.bootcss.com/sweetalert/1.1.3/sweetalert.min.js"></script>

    <script>
      document.body.oncopy = function() {
        swal("复制成功！", "若要转载请保留原文链接，谢谢合作！","success");
      };
    </script>


  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jijiking51.cn/2019/08/19/redis学习wiki/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="RocWong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RocWong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">redis学习wiki

          
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-19 16:51:19" itemprop="dateCreated datePublished" datetime="2019-08-19T16:51:19+08:00">2019-08-19</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-25 12:09:19" itemprop="dateModified" datetime="2019-08-25T12:09:19+08:00">2019-08-25</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            <span id="/2019/08/19/redis学习wiki/" class="post-meta-item leancloud_visitors" data-flag-title="redis学习wiki" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
        
      
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019/08/19/redis学习wiki/#comments" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/19/redis学习wiki/" itemprop="commentCount"></span></a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><h2 id="了解redis的数据库，了解相似的缓存数据库，redis的局限"><a href="#了解redis的数据库，了解相似的缓存数据库，redis的局限" class="headerlink" title="了解redis的数据库，了解相似的缓存数据库，redis的局限"></a>了解redis的数据库，了解相似的缓存数据库，redis的局限</h2><h3 id="redis数据库"><a href="#redis数据库" class="headerlink" title="redis数据库"></a>redis数据库</h3><ol>
<li><p>非关系型数据库</p>
</li>
<li><p>以键(key)和值(value)做映射(mapping)</p>
<p>value类型：</p>
<ul>
<li>string：字符串对象</li>
<li>list：列表对象</li>
<li>hash：哈希对象</li>
<li>set：集合对象</li>
<li>zset：有序集合对象</li>
</ul>
</li>
</ol><table id="jump1"><thead><th style="text-align:center">类型(前缀：REDIS)</th><th style="text-align:center">编码(前缀：REDIS_ENCODING)</th><th style="text-align:center">对象</th><th style="text-align:center">结构的读写能力</th></thead><tbody><tr><td style="text-align:center">STRING</td><td style="text-align:center">INT(long类型整数)</td><td style="text-align:center">整数值实现字符串对象</td><td rowspan="3" style="text-align:center">对整个字符串或者字符串的其一部分执行操作，对整数的浮点数执行自增或者自减操作</td></tr><tr><td style="text-align:center">STRING</td><td style="text-align:center">EMBSTR(embstr编码的简单字符串)</td><td style="text-align:center">embstr编码的简单动态字符串实现的字符串对象</td></tr><tr><td style="text-align:center">STRING</td><td style="text-align:center">RAW(简单动态字符串)</td><td style="text-align:center">动态字符串实现的字符串对象</td></tr><tr><td style="text-align:center">LIST</td><td style="text-align:center">ZIPLIST(压缩列表)</td><td style="text-align:center">压缩列表实现的列表对象</td><td rowspan="2" style="text-align:center">从链表的两端推入或者弹出元素，根据偏移量对链表进行修剪，读取单个或者多个元素，根据值查找或者移除元素</td></tr><tr><td style="text-align:center">LIST</td><td style="text-align:center">LINKEDLIST(双端链表)</td><td style="text-align:center">双端链表实现的列表对象</td></tr><tr><td style="text-align:center">HASH</td><td style="text-align:center">ZIPLIST(压缩列表)</td><td style="text-align:center">压缩列表实现的哈希对象</td><td rowspan="2" style="text-align:center">添加、获取、移除单个键值对，获取所有键值对</td></tr><tr><td style="text-align:center">HASH</td><td style="text-align:center">HT(字典)</td><td style="text-align:center">字典实现的哈希对象</td></tr><tr><td style="text-align:center">SET</td><td style="text-align:center">INTSET(整数集合)</td><td style="text-align:center">整数集合实现的集合对象</td><td rowspan="2" style="text-align:center">添加、获取、移除单个元素，检查一个元素是否存在与集合，计算交集，并集，差集，从集合里面随机获取元素</td></tr><tr><td style="text-align:center">SET</td><td style="text-align:center">HT(字典)</td><td style="text-align:center">字典实现的集合对象</td></tr><tr><td style="text-align:center">ZSET</td><td style="text-align:center">ZIPLIST(压缩列表)</td><td style="text-align:center">压缩列表实现的有序集合对象</td><td rowspan="2" style="text-align:center">添加、获取、移除单个元素，根据分值范围或者成员来获取元素</td></tr><tr><td style="text-align:center">ZSET</td><td style="text-align:center">SKIPLIST(跳跃表和字典)</td><td style="text-align:center">跳跃表和字典实现的有序集合对象</td></tr></tbody></table><a id="more"></a>




<ol start="3">
<li>可以将内存中的数据进行落盘<ul>
<li>存储命令<ul>
<li>save：主线程将数据快照存储为rdb，存储期间redis不接受其他请求</li>
<li>bgsave：fork一个子进程进行快照存储，存储期间redis可以处理其他请求</li>
</ul>
</li>
<li>存储方式<ul>
<li>时间点转储：在指定时间内进行了指定次数的操作即可开始转储</li>
<li>AOF存储：每条修改命令都追加写入AOF文件， 可以设置成每秒追加或者每一条都追加</li>
</ul>
</li>
</ul>
</li>
<li>读性能扩展： 利用复制特性，例如主从服务器进行读写分离</li>
<li>写性能扩张： 利用客户端分片， 例如 mod( hash(id), n) = x, 通过这个方法就可以得到id在n台服务器的情况下存储到第x服务器上</li>
<li>速度快：10QPS/s<ul>
<li>内存操作</li>
<li>C语言实现，最接近底层</li>
<li>单线程架构，预防多线程可能产生问题</li>
<li>redis的精细打磨</li>
</ul>
</li>
</ol>
<h3 id="相似类型数据库对比"><a href="#相似类型数据库对比" class="headerlink" title="相似类型数据库对比"></a>相似类型数据库对比</h3><table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">数据存储选项</th>
<th style="text-align:center">查询类型</th>
<th style="text-align:center">附加功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Redis</td>
<td style="text-align:center">使用内存存储的NoSql</td>
<td style="text-align:center">字符串、列表、集合、散列表、有序集合</td>
<td style="text-align:center">每种数据类型都有自己的专属命令，另外还有批量操作和不完全的事物支持</td>
<td style="text-align:center">发布与订阅，主从复制，持久化，脚本（存储过程）</td>
</tr>
<tr>
<td style="text-align:center">memcached</td>
<td style="text-align:center">使用内存存储的键值缓存</td>
<td style="text-align:center">键值字符串映射</td>
<td style="text-align:center">创建、读取、更新、删除等命令</td>
<td style="text-align:center">为提升性能而设的多线程服务器</td>
</tr>
<tr>
<td style="text-align:center">mysql</td>
<td style="text-align:center">关系数据库</td>
<td style="text-align:center">每个数据库可以包含多个表，每个表可以包含多个行，可以处理多个表的视图，支持空间和第三方扩展</td>
<td style="text-align:center">SELECT、INSERT、UPDATE、DELETE、函数、存储过程</td>
<td style="text-align:center">支持ACID性质、主从复制和主主复制</td>
</tr>
<tr>
<td style="text-align:center">postgreSql</td>
<td style="text-align:center">关系数据库</td>
<td style="text-align:center">每个数据库可以包含多个表，每个表可以包含多个行，可以处理多个表的视图，支持空间和第三方扩展，支持可定制类型</td>
<td style="text-align:center">SELECT、INSERT、UPDATE、DELETE、内置函数、自定义的存储过程</td>
<td style="text-align:center">支持ACID性质，主从复制，第三方支持的多复制</td>
</tr>
<tr>
<td style="text-align:center">MongoDB</td>
<td style="text-align:center">使用硬盘存储的非关系文档存储</td>
<td style="text-align:center">每个数据库可以包含多个表，每个表可以包含多个无schema的BSON文档</td>
<td style="text-align:center">创建命令、读取命令、更新命令、删除命令、条件查询命令等</td>
<td style="text-align:center">支持map-reduce操作、主从复制、分片、空间索引</td>
</tr>
</tbody>
</table>
<h4 id="redis对比其他数据库优势"><a href="#redis对比其他数据库优势" class="headerlink" title="redis对比其他数据库优势"></a>redis对比其他数据库优势</h4><ul>
<li><p>列表管理：拥有List和Set两种类型可以直接添加或者删除元素</p>
</li>
<li><p>数据存储：</p>
<ul>
<li>原子的INCR命令及其变种来计算聚合数据，因为数据存储在内存中，不需要经过查询分析器或者查询优化器处理</li>
<li>避免写入不必要的临时数据，也免去对临时数据进行扫描或者删除的麻烦</li>
</ul>
</li>
</ul>
<h3 id="redis用途"><a href="#redis用途" class="headerlink" title="redis用途"></a>redis用途</h3><ol>
<li><p>缓存</p>
<p>减缓后端压力，加快访问速度</p>
</li>
<li><p>排行版系统</p>
<p>redis提供列表和有序集合数据结构</p>
</li>
<li><p>计数器应用</p>
<p>高并发特性，支持计数功能</p>
</li>
<li><p>社交网络</p>
<p>数据结构多样，适应多种数据存储类型</p>
</li>
<li><p>消息队列系统</p>
<p>发布订阅和阻塞队列功能可以满足基本的消息队列功能</p>
</li>
</ol>
<h3 id="redis局限"><a href="#redis局限" class="headerlink" title="redis局限"></a>redis局限</h3><ol>
<li>大量数据的存储局限性</li>
<li>冷热数据处理——热数据应该放置内存中，冷数据不应该放在内存中浪费内存</li>
</ol>
<h2 id="输出一个redis实例的linux环境安装文档，包括安装步骤，配置，启动关闭等"><a href="#输出一个redis实例的linux环境安装文档，包括安装步骤，配置，启动关闭等" class="headerlink" title="输出一个redis实例的linux环境安装文档，包括安装步骤，配置，启动关闭等"></a>输出一个redis实例的linux环境安装文档，包括安装步骤，配置，启动关闭等</h2><h3 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h3><ol>
<li><p>下载源码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># wget工具可以通过以下命令安装</span></span><br><span class="line">apt-get install wget</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>解压</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-5.0.0.tar.gz</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis文件夹</span></span><br><span class="line"><span class="built_in">cd</span> redis-5.0.5</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试是否正确</span></span><br><span class="line">make <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错1</span></span><br><span class="line"><span class="built_in">cd</span> src &amp;&amp; make all</span><br><span class="line">make[1]: Entering directory <span class="string">'/root/redis-5.0.5/src'</span></span><br><span class="line">    CC adlist.o</span><br><span class="line">/bin/sh: 1: cc: not found</span><br><span class="line">Makefile:248: recipe <span class="keyword">for</span> target <span class="string">'adlist.o'</span> failed</span><br><span class="line">make[1]: *** [adlist.o] Error 127</span><br><span class="line">make[1]: Leaving directory <span class="string">'/root/redis-5.0.5/src'</span></span><br><span class="line">Makefile:6: recipe <span class="keyword">for</span> target <span class="string">'all'</span> failed</span><br><span class="line">make: *** [all] Error 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错原因[1]——没有安装gcc</span></span><br><span class="line">apt-get install gcc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错2</span></span><br><span class="line"><span class="built_in">cd</span> src &amp;&amp; make all</span><br><span class="line">make[1]: Entering directory <span class="string">'/root/redis-5.0.5/src'</span></span><br><span class="line">    CC adlist.o</span><br><span class="line">In file included from adlist.c:34:0:</span><br><span class="line">zmalloc.h:50:10: fatal error: jemalloc/jemalloc.h: No such file or directory</span><br><span class="line"> <span class="comment">#include &lt;jemalloc/jemalloc.h&gt;</span></span><br><span class="line">          ^~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">Makefile:248: recipe <span class="keyword">for</span> target <span class="string">'adlist.o'</span> failed</span><br><span class="line">make[1]: *** [adlist.o] Error 1</span><br><span class="line">make[1]: Leaving directory <span class="string">'/root/redis-5.0.5/src'</span></span><br><span class="line">Makefile:6: recipe <span class="keyword">for</span> target <span class="string">'all'</span> failed</span><br><span class="line">make: *** [all] Error 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错原因[2]——关于分配器allocator， 如果有MALLOC  这个 环境变量， 会有用这个环境变量的 去建立Redis。而且libc 并不是默认的 分配器， 默认的是jemalloc, 因为 jemalloc被证明比libc有更少的 碎片问题 。但是如果你又没有jemalloc 而只有 libc 当然 make 出错。 </span></span><br><span class="line">make MALLOC=libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错3</span></span><br><span class="line">You need tcl 8.5 or newer <span class="keyword">in</span> order to run the Redis <span class="built_in">test</span></span><br><span class="line">make:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方法——安装tcl</span></span><br><span class="line">apt-get install tcl</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="配置文件翻译"><a href="#配置文件翻译" class="headerlink" title="配置文件翻译"></a>配置文件翻译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">######################### 引用 #########################</span><br><span class="line"></span><br><span class="line"># 不同redis server可以使用同一个模版配置作为主配置，并引用其它配置文件用于本server的个性# 化设置</span><br><span class="line"># include并不会被CONFIG REWRITE命令覆盖。但是主配置文件的选项会被覆盖。</span><br><span class="line"># 想故意覆盖主配置的话就把include放文件前面，否则最好放末尾</span><br><span class="line"># include /path/to/local.conf</span><br><span class="line"># include /path/to/other.conf</span><br><span class="line"></span><br><span class="line">######################### 网络 #########################</span><br><span class="line"></span><br><span class="line"># 不指定bind的话redis将会监听所有网络接口。这个配置是肯定需要指定的。</span><br><span class="line"># Examples:</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line"># 下面这个配置是只允许本地客户端访问。</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 是否开启保护模式。默认开启，如果没有设置bind项的ip和redis密码的话，服务将只允许本地访 问。</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 端口设置，默认为 6379 </span><br><span class="line"># 如果port设置为0 redis将不会监听tcp socket</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 在高并发环境下需要一个高backlog值来避免慢客户端连接问题。注意Linux内核默默将这个值减小到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog 两个值来达到需要的效果。</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"># 指定用来监听Unix套套接字的路径。没有默认值，没有指定的情况下Redis不会监听Unix socket</span><br><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line"># 客户端空闲多少秒后关闭连接（0为不关闭）timeout 0# tcp-keepalive设置。如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK，用途如下：</span><br><span class="line"># 1）能够检测无响应的对端</span><br><span class="line"># 2）让该连接中间的网络设备知道这个连接还存活</span><br><span class="line"># 在Linux上，这个指定的值(单位秒)就是发送ACK的时间间隔。</span><br><span class="line"># 注意：要关闭这个连接需要两倍的这个时间值。</span><br><span class="line"># 在其他内核上这个时间间隔由内核配置决定# 从redis3.2.1开始默认值为300秒</span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line">######################### 通用 #########################</span><br><span class="line"></span><br><span class="line"># 是否将Redis作为守护进程运行。如果需要的话配置成&apos;yes&apos;</span><br><span class="line"># 注意配置成守护进程后Redis会将进程号写入文件/var/run/redis.pid</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"># 是否通过upstart或systemd管理守护进程。默认no没有服务监控，其它选项有upstart, systemd, auto</span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"># pid文件在redis启动时创建，退出时删除。最佳实践为配置该项。</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"># 配置日志级别。选项有debug, verbose, notice, warning</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"># 日志名称。空字符串表示标准输出。注意如果redis配置为后台进程，标准输出中信息会发送到/dev/null</span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 是否启动系统日志记录。</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line"># 指定系统日志身份。</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line"># 指定syslog设备。必须是user或LOCAL0 ~ LOCAL7之一。</span><br><span class="line"># syslog-facility local0</span><br><span class="line"></span><br><span class="line"># 设置数据库个数。默认数据库是 DB 0</span><br><span class="line"># 可以通过SELECT where dbid is a number between 0 and &apos;databases&apos;-1为每个连接使用不同的数据库。</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">######################### 备份  #########################</span><br><span class="line"># 持久化设置:</span><br><span class="line"># 下面的例子将会进行把数据写入磁盘的操作:</span><br><span class="line">#   900秒（15分钟）之后，且至少1次变更</span><br><span class="line">#   300秒（5分钟）之后，且至少10次变更</span><br><span class="line">#   60秒之后，且至少10000次变更</span><br><span class="line"># 不写磁盘的话就把所有 &quot;save&quot; 设置注释掉就行了。</span><br><span class="line"># 通过添加一条带空字符串参数的save指令也能移除之前所有配置的save指令，如: save &quot;&quot;</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 默认情况下如果上面配置的RDB模式开启且最后一次的保存失败，redis 将停止接受写操作，让用户知道问题的发生。</span><br><span class="line"># 如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。如果有其它监控方式也可关闭。</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 是否在备份.rdb文件时是否用LZF压缩字符串，默认设置为yes。如果想节约cpu资源可以把它设置为no。</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 因为版本5的RDB有一个CRC64算法的校验和放在了文件的末尾。这将使文件格式更加可靠,</span><br><span class="line"># 但在生产和加载RDB文件时，这有一个性能消耗(大约10%)，可以关掉它来获取最好的性能。</span><br><span class="line"># 生成的关闭校验的RDB文件有一个0的校验和，它将告诉加载代码跳过检查rdbchecksum yes</span><br><span class="line"># rdb文件名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 备份文件目录，文件名就是上面的 &quot;dbfilename&quot; 的值。累加文件也放这里。</span><br><span class="line"># 注意你这里指定的必须是目录，不是文件名。</span><br><span class="line">dir /your data path/</span><br><span class="line"></span><br><span class="line">######################### 主从同步 #########################</span><br><span class="line"></span><br><span class="line"># 主从同步配置。</span><br><span class="line"># 1) redis主从同步是异步的，但是可以配置在没有指定slave连接的情况下使master停止写入数据。</span><br><span class="line"># 2) 连接中断一定时间内，slave可以执行部分数据重新同步。</span><br><span class="line"># 3) 同步是自动的，slave可以自动重连且同步数据。</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># master连接密码</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line"># 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：</span><br><span class="line"># 1) 如果 slave-serve-stale-data 设置为 &quot;yes&quot; (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。</span><br><span class="line"># 2) 如果 slave-serve-stale-data 设置为 &quot;no&quot;，slave会回复&quot;正在从master同步（SYNC with master in progress）&quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># 你可以配置salve实例是否接受写操作。可写的slave实例可能对存储临时数据比较有用(因为写入salve# 的数据在同master同步之后将很容被删除)，但是如果客户端由于配置错误在写入时也可能产生一些问题。</span><br><span class="line"># 从Redis2.6默认所有的slave为只读</span><br><span class="line"># 注意:只读的slave不是为了暴露给互联网上不可信的客户端而设计的。它只是一个防止实例误用的保护层。</span><br><span class="line"># 一个只读的slave支持所有的管理命令比如config,debug等。为了限制你可以用&apos;rename-command&apos;来隐藏所有的管理和危险命令来增强只读slave的安全性。</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"># 同步策略: 磁盘或socket，默认磁盘方式</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># 如果非磁盘同步方式开启，可以配置同步延迟时间，以等待master产生子进程通过socket传输RDB数据给slave。</span><br><span class="line"># 默认值为5秒，设置为0秒则每次传输无延迟。</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"># slave根据指定的时间间隔向master发送ping请求。默认10秒。</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line"># 同步的超时时间</span><br><span class="line"># 1）slave在与master SYNC期间有大量数据传输，造成超时</span><br><span class="line"># 2）在slave角度，master超时，包括数据、ping等</span><br><span class="line"># 3）在master角度，slave超时，当master发送REPLCONF ACK pings# 确保这个值大于指定的repl-ping-slave-period，否则在主从间流量不高时每次都会检测到超时</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># 是否在slave套接字发送SYNC之后禁用 TCP_NODELAY</span><br><span class="line"># 如果选择yes，Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave上有延迟，Linux内核的默认配置会达到40毫秒。</span><br><span class="line"># 如果选择no，数据传输到salve的延迟将会减少但要使用更多的带宽。</span><br><span class="line"># 默认我们会为低延迟做优化，但高流量情况或主从之间的跳数过多时，可以设置为“yes”。</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># 设置数据备份的backlog大小。backlog是一个slave在一段时间内断开连接时记录salve数据的缓冲，所以一个slave在重新连接时，不必要全量的同步，而是一个增量同步就足够了，将在断开连接的这段# 时间内把slave丢失的部分数据传送给它。</span><br><span class="line"># 同步的backlog越大，slave能够进行增量同步并且允许断开连接的时间就越长。</span><br><span class="line"># backlog只分配一次并且至少需要一个slave连接。</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"># 当master在一段时间内不再与任何slave连接，backlog将会释放。以下选项配置了从最后一个</span><br><span class="line"># slave断开开始计时多少秒后，backlog缓冲将会释放。</span><br><span class="line"># 0表示永不释放backlog</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># slave的优先级是一个整数展示在Redis的Info输出中。如果master不再正常工作了，sentinel将用它来选择一个slave提升为master。</span><br><span class="line"># 优先级数字小的salve会优先考虑提升为master，所以例如有三个slave优先级分别为10，100，25，sentinel将挑选优先级最小数字为10的slave。</span><br><span class="line"># 0作为一个特殊的优先级，标识这个slave不能作为master，所以一个优先级为0的slave永远不会被# sentinel挑选提升为master。</span><br><span class="line"># 默认优先级为100</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"># 如果master少于N个延时小于等于M秒的已连接slave，就可以停止接收写操作。</span><br><span class="line"># N个slave需要是“oneline”状态。</span><br><span class="line"># 延时是以秒为单位，并且必须小于等于指定值，是从最后一个从slave接收到的ping（通常每秒发送）开始计数。</span><br><span class="line"># 该选项不保证N个slave正确同步写操作，但是限制数据丢失的窗口期。</span><br><span class="line"># 例如至少需要3个延时小于等于10秒的slave用下面的指令：</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line"></span><br><span class="line"># 两者之一设置为0将禁用这个功能。</span><br><span class="line"># 默认 min-slaves-to-write 值是0（该功能禁用）并且 min-slaves-max-lag 值是10。</span><br><span class="line"></span><br><span class="line">######################### 安全 #########################</span><br><span class="line"></span><br><span class="line"># 要求客户端在处理任何命令时都要验证身份和密码。</span><br><span class="line"># requirepass foobared</span><br><span class="line"></span><br><span class="line"># 命令重命名</span><br><span class="line"># 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，这样内部的工具仍然可以使用。</span><br><span class="line"># 例如：</span><br><span class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line"># 也可以通过改名为空字符串来完全禁用一个命令</span><br><span class="line"># rename-command CONFIG &quot;&quot;</span><br><span class="line"># 请注意：改变命令名字被记录到AOF文件或被传送到从服务器可能产生问题。</span><br><span class="line"></span><br><span class="line">######################### 限制 #########################</span><br><span class="line"></span><br><span class="line"># 设置最多同时连接的客户端数量。默认这个限制是10000个客户端，然而如果Redis服务器不能配置</span><br><span class="line"># 处理文件的限制数来满足指定的值，那么最大的客户端连接数就被设置成当前文件限制数减32（因为Redis服务器保留了一些文件描述符作为内部使用）</span><br><span class="line"># 一旦达到这个限制，Redis会关闭所有新连接并发送错误&apos;max number of clients reached&apos;</span><br><span class="line"># maxclients 10000</span><br><span class="line"></span><br><span class="line"># 不要使用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：maxmemmory-policy）删除key。</span><br><span class="line"># 如果因为删除策略Redis无法删除key，或者策略设置为 &quot;noeviction&quot;，Redis会回复需要更多内存的错误信息给命令。例如，SET,LPUSH等等，但是会继续响应像Get这样的只读命令。</span><br><span class="line"># 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &quot;noeviction&quot; 策略）的时候，这个选项通常事很有用的。</span><br><span class="line"># 警告：当有多个slave连上达到内存上限时，master为同步slave的输出缓冲区所需内存不计算在使用内存中。这样当移除key时，就不会因网络问题 / 重新同步事件触发移除key的循环，反过来slaves的输出缓冲区充满了key被移除的DEL命令，这将触发删除更多的key，直到这个数据库完全被清空为止。</span><br><span class="line"># 总之，如果你需要附加多个slave，建议你设置一个稍小maxmemory限制，这样系统就会有空闲的内存作为slave的输出缓存区(但是如果最大内存策略设置为&quot;noeviction&quot;的话就没必要了)</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line"># 最大内存策略：如果达到内存限制了，Redis如何选择删除key。</span><br><span class="line"># volatile-lru -&gt; 根据LRU算法删除设置过期时间的key</span><br><span class="line"># allkeys-lru -&gt; 根据LRU算法删除任何key</span><br><span class="line"># volatile-random -&gt; 随机移除设置过过期时间的key</span><br><span class="line"># allkeys-random -&gt; 随机移除任何key</span><br><span class="line"># volatile-ttl -&gt; 移除即将过期的key(minor TTL)</span><br><span class="line"># noeviction -&gt; 不移除任何key，只返回一个写错误</span><br><span class="line"># 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。# 目前为止涉及的命令：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort</span><br><span class="line"># 默认策略:</span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"># LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样本量做检测。 例如：默认Redis会检查3个key然后取最旧的那个，你可以通过下面的配置指令来设置样本的个数。</span><br><span class="line"># 默认值为5，数字越大结果越精确但是会消耗更多CPU。</span><br><span class="line"># maxmemory-samples 5</span><br><span class="line"></span><br><span class="line">######################### APPEND ONLY MODE #########################</span><br><span class="line"></span><br><span class="line"># 默认情况下，Redis是异步的把数据导出到磁盘上。这种模式在很多应用里已经足够好，但Redis进程出问题或断电时可能造成一段时间的写操作丢失(这取决于配置的save指令)。</span><br><span class="line"># AOF是一种提供了更可靠的替代持久化模式，例如使用默认的数据写入文件策略（参见后面的配置）。</span><br><span class="line"># 在遇到像服务器断电或单写情况下Redis自身进程出问题但操作系统仍正常运行等突发事件时，Redis能只丢失1秒的写操作。</span><br><span class="line"># AOF和RDB持久化能同时启动并且不会有问题。</span><br><span class="line"># 如果AOF开启，那么在启动时Redis将加载AOF文件，它更能保证数据的可靠性。</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># AOF文件名（默认：&quot;appendonly.aof&quot;）</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># fsync() 系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。</span><br><span class="line"># 有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。</span><br><span class="line"># Redis支持三种不同的模式：</span><br><span class="line"># no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。</span><br><span class="line"># always：每次写操作都立刻写入到aof文件。慢，但是最安全。</span><br><span class="line"># everysec：每秒写一次。折中方案。</span><br><span class="line"># 默认的 &quot;everysec&quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line"># 如果AOF的同步策略设置成 &quot;always&quot; 或者 &quot;everysec&quot;，并且后台的存储进程（后台存储或写入AOF 日志）会产生很多磁盘I/O开销。某些Linux的配置下会使Redis因为 fsync()系统调用而阻塞很久。</span><br><span class="line"># 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的write(2)调用。</span><br><span class="line"># 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止fsync()。</span><br><span class="line"># 这就意味着如果有子进程在进行保存操作，那么Redis就处于&quot;不可同步&quot;的状态。</span><br><span class="line"># 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）</span><br><span class="line"># 如果把这个设置成&quot;yes&quot;带来了延迟问题，就保持&quot;no&quot;，这是保存持久数据的最安全的方式。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 自动重写AOF文件。如果AOF日志文件增大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。# 工作原理：Redis记住上次重写时AOF文件的大小（如果重启后还没有写操作，就直接用启动时的AOF大小）</span><br><span class="line"># 这个基准大小和当前大小做比较。如果当前大小超过指定比例，就会触发重写操作。你还需要指定被重写日志的最小尺寸，这样避免了达到指定百分比但尺寸仍然很小的情况还要重写。</span><br><span class="line"># 指定百分比为0会禁用AOF自动重写特性。</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 如果设置为yes，如果一个因异常被截断的AOF文件被redis启动时加载进内存，redis将会发送日志通知用户。如果设置为no，erdis将会拒绝启动。此时需要用&quot;redis-check-aof&quot;工具修复文件。</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">######################### 集群 #########################</span><br><span class="line"></span><br><span class="line"># 只有开启了以下选项，redis才能成为集群服务的一部分</span><br><span class="line"># cluster-enabled yes</span><br><span class="line"></span><br><span class="line"># 配置redis自动生成的集群配置文件名。确保同一系统中运行的各redis实例该配置文件不要重名。</span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"># 集群节点超时毫秒数。超时的节点将被视为不可用状态。</span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line"></span><br><span class="line"># 如果数据太旧，集群中的不可用master的slave节点会避免成为备用master。如果slave和master失联时间超过:(node-timeout * slave-validity-factor) + repl-ping-slave-period则不会被提升为master。</span><br><span class="line"># 如node-timeout为30秒，slave-validity-factor为10, 默认default repl-ping-slave-period为10秒,失联时间超过310秒slave就不会成为master。</span><br><span class="line"># 较大的slave-validity-factor值可能允许包含过旧数据的slave成为master，同时较小的值可能会阻止集群选举出新master。</span><br><span class="line">#为了达到最大限度的高可用性，可以设置为0，即slave不管和master失联多久都可以提升为master</span><br><span class="line"># cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"># 只有在之前master有其它指定数量的工作状态下的slave节点时，slave节点才能提升为master。默认为1（即该集群至少有3个节点，1 master＋2 slaves，master宕机，仍有另外1个slave的情况下其中1个slave可以提升）</span><br><span class="line"># 测试环境可设置为0，生成环境中至少设置为1</span><br><span class="line"># cluster-migration-barrier 1</span><br><span class="line"></span><br><span class="line"># 默认情况下如果redis集群如果检测到至少有1个hash slot不可用，集群将停止查询数据。</span><br><span class="line"># 如果所有slot恢复则集群自动恢复。</span><br><span class="line"># 如果需要集群部分可用情况下仍可提供查询服务，设置为no。</span><br><span class="line"># cluster-require-full-coverage yes</span><br><span class="line"></span><br><span class="line">######################### 慢查询日志 #########################</span><br><span class="line"></span><br><span class="line"># 慢查询日志，记录超过多少微秒的查询命令。查询的执行时间不包括客户端的IO执行和网络通信时间，只是查询命令执行时间。</span><br><span class="line"># 1000000等于1秒，设置为0则记录所有命令</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># 记录大小，可通过SLOWLOG RESET命令重置</span><br><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure>
<h3 id="启动与关闭redis"><a href="#启动与关闭redis" class="headerlink" title="启动与关闭redis"></a>启动与关闭redis</h3><ol>
<li><p>建立redis数据存储目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/redis_data</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立redis日志存储目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/redis_log</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件中的数据存储路径和日志存储路径</p>
</li>
<li><p>启动redis</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /root/redis-5.0.5/redis.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接并关闭</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">redis-cli -h [ip] -p [port]</span><br><span class="line">shutdown [<span class="built_in">command</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line">redis-cli -h [ip] -p [port] shutdown [<span class="built_in">command</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># command 是可选参数</span></span><br><span class="line">save：持久化数据</span><br><span class="line">nosave： 不持久化数据</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><h2 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h2><ol>
<li><p>查看所有键值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产环境中可能会有很多键值，这个命令不要用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>键总数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查键是否存在</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除键</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置过期时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取键过期剩余时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于0 代表过期剩余时间</span></span><br><span class="line"><span class="comment"># -1  没有设置过过期时间</span></span><br><span class="line"><span class="comment"># -2  键不存在</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>键的数据结构类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果键不存在返回none</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="字符串命令"><a href="#字符串命令" class="headerlink" title="字符串命令"></a>字符串命令</h2><ol>
<li><p>设置值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key value [ex seconds] [px milliseconds] [nx | xx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时有setnx 和 setex两个命令</span></span><br><span class="line">setnx = <span class="built_in">set</span> key value nx</span><br><span class="line">setex = <span class="built_in">set</span> key value ex</span><br><span class="line"></span><br><span class="line"><span class="comment"># setnx 可以用于分布式锁， 因为redis是单线程处理机制， setnx key value 命令只会有一个用户设置成功</span></span><br></pre></td></tr></table></figure>
<p>ex seconds: 设置过期时间，秒</p>
<p>px milliseconds: 设置过期时间， 毫秒</p>
<p>nx: 键必须不存在才能被设置成功，用于添加</p>
<p>xx: 键必须存在才能被设置成功，用于更新</p>
</li>
<li><p>获取值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量设置值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量获取值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>计数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整数自增加1</span></span><br><span class="line">incr key</span><br><span class="line"><span class="comment"># 整数自减减1</span></span><br><span class="line">decr key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数自增指定数</span></span><br><span class="line">incrby key increment</span><br><span class="line"><span class="comment"># 整数自减指定数 </span></span><br><span class="line">decrby key decrement</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自增浮点数 如果要减就设置负数</span></span><br><span class="line">incrbyfloat key increment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况1. 值不是整数， 返回错误</span></span><br><span class="line"><span class="comment"># 情况2. 键不存在， 按照值为0， 自增</span></span><br><span class="line"><span class="comment"># 情况3. 值是整数，返回自增后结果</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>追加值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append key value</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串字节长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果key不存在返回0</span></span><br><span class="line"><span class="comment"># 中文占三个字节， 所以一个中文长度为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置并返回值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getset key value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先获取这个key目前的内容值</span></span><br><span class="line"><span class="comment"># 然后设置这个key的值为value</span></span><br><span class="line"><span class="comment"># 如果没有这个key 则返回值为nil， 否则为设置之前获取的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置指定位置的字符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setrange key offeset value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定位置的字符会被替换， 如果指定的offeset大于目前字符串长度，中间缺少的长度会用\x00填充</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取部分字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getrange key start end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果start为负数将从最后开始计数</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><ol>
<li><p>设置值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希操作也提供了hsetnx命令，和string操作中的setnx用法相同只是vulue变成field</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget key field</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除field</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hdel key field [field ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的数字是删除个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算field个数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量设置获取field-value</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field ...]</span><br><span class="line">hmset key field value [field value  ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断field是否存在</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists key field</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有field</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkey key</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有的value</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hvals key</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有的field-value</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br><span class="line"></span><br><span class="line"><span class="comment"># hgetall如果field过多会导致阻塞， 如果要获取全部用hscan命令， hscan会渐进式遍历哈希</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>哈希计数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hincrby key field</span><br><span class="line">hicrbyfloat key field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hincrby 等同于 incrby</span></span><br><span class="line"><span class="comment"># hincrbyfloat 等同于 incrby</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算value的字符串长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hstrlen key field</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><ol>
<li><p>从右边插入元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpush key value [value ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>从左边插入元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush key value [value ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>向第一个相同元素的前或者后插入元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linsert key before|after pivot value</span><br><span class="line"></span><br><span class="line"><span class="comment"># linsert 只会匹配第一个相同的pivot， 修改成功后就会借书</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol>
<li><p>获取指定范围内的元素列表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lrange key start end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从左到右获取是0 —— n-1， 从右到左获取是 -1 到 -n，， 获取所有的内容 lrange key 0 -1</span></span><br><span class="line"><span class="comment"># lrange的start和end都包括了自身</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取列表指定索引下标的元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lindex key index</span><br><span class="line"></span><br><span class="line"><span class="comment"># index &gt;= 0 从左往右</span></span><br><span class="line"><span class="comment"># index &lt; 0 从右往左</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取列表长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llen key</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol>
<li><p>从左往右删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpop key</span><br></pre></td></tr></table></figure>
</li>
<li><p>从右往左删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpop key</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lrem key count value</span><br><span class="line"></span><br><span class="line"><span class="comment"># count&gt;0  从左往右删除最多count个匹配的结果</span></span><br><span class="line"><span class="comment"># count&lt;0  从右往左删除最多count个匹配的结果</span></span><br><span class="line"><span class="comment"># count=0  删除所有匹配的结果</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按照索引范围修剪列表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ltrim key start end</span><br><span class="line"></span><br><span class="line"><span class="comment">#  只会保留start 到  end 的内容， 如果这个范围为空， 则列表也会为空</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ol>
<li><p>修改指定索引下标的元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lset key index value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果这个key 或者index 超过这个list的长度，会报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>阻塞操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">blpop key [key ... ] timeout</span><br><span class="line">brpop key [key ... ] timeout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞操作是弹出操作的阻塞版本</span></span><br><span class="line"><span class="comment"># timeout 是阻塞的时间</span></span><br><span class="line"><span class="comment"># 如果列表不为空会立马返回</span></span><br><span class="line"><span class="comment"># 如果列表为空， 那么就要将阻塞timeout时间， 当timeout=0时会一直阻塞</span></span><br><span class="line"><span class="comment"># 如果在阻塞期间添加了数据，阻塞端会立即返回数据</span></span><br><span class="line"><span class="comment"># 如果是多个key， 那么阻塞期间会从左至右遍历key， 一旦有一个key不为空则立马返回</span></span><br><span class="line"><span class="comment"># 如果是多个客户端同时阻塞获取同一个key， 会按照请求的时间顺序返回，先来先服务</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合内操作"><a href="#集合内操作" class="headerlink" title="集合内操作"></a>集合内操作</h3><ol>
<li><p>添加元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key element [element ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key element [element ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算元素个数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断元素是否在集合中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key element</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机从集合返回指定个数元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count] <span class="comment"># count不写 默认为1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>从集合随机弹出元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key [count] <span class="comment"># count不写 默认为1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br><span class="line"><span class="comment"># 返回结果是无序结果</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="集合间操作"><a href="#集合间操作" class="headerlink" title="集合间操作"></a>集合间操作</h3><ol>
<li><p>求多个集合的交集</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>求多个集合的并集</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sunion key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>求多个集合的差集</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdiff key [key ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>将交集、并集、差集的结果保存</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key [key ...]</span><br><span class="line">sunionstore destination key [key ...]</span><br><span class="line">sdiffstore destination key [key ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令=原命令+store</span></span><br><span class="line"><span class="comment"># destination： 给结果value一个key名称</span></span><br><span class="line"><span class="comment"># key [key ...] :需要进行的操作集合</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="集合内"><a href="#集合内" class="headerlink" title="集合内"></a>集合内</h3><ol>
<li><p>添加成员</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member [score member ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># zadd 后有四个可选项</span></span><br><span class="line"><span class="comment"># nx：member必须不存在才可以设置成功，用于添加</span></span><br><span class="line"><span class="comment"># xx：member必须存在才可以设置成功， 用于修改</span></span><br><span class="line"><span class="comment"># ch：返回此次操作后有序集合元素和分数发生变化的个数</span></span><br><span class="line"><span class="comment"># incr：对score做增加，相当于zincrby</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add的时间复杂度为log n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>计算成员个数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取某个成员的分数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算某个成员的排名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br><span class="line">zrevrank key member</span><br><span class="line"></span><br><span class="line"><span class="comment"># zrank 是从低到高</span></span><br><span class="line"><span class="comment"># zrevrank 是从高到低</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一位是0， 没找到为nil</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除成员</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key member [member ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加成员的分数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zincrby key increment member</span><br><span class="line"></span><br><span class="line"><span class="comment"># increment：增加的分数</span></span><br><span class="line"><span class="comment"># 如果key不存在则会添加这个key，并将increment设置为初始分数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回指定排名范围的成员</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zrange key start end [withscores]</span><br><span class="line">zrevrange key start end [withscores]</span><br><span class="line"></span><br><span class="line"><span class="comment"># zrange从低到高， zrevrange从高到低</span></span><br><span class="line"><span class="comment"># 如果加上withscores会加上分数一并返回</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回指定分数范围的成员</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore key min max [withscores] [<span class="built_in">limit</span> offset count]</span><br><span class="line">zrevrangebyscore key min max [withscores] [<span class="built_in">limit</span> offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># zrangebyscore从低到高， zrevrangebyscore 从高到低</span></span><br><span class="line"><span class="comment"># min 和 max 表示 min &lt;= score &lt;= max, 如果想使用开区间， 也就是 min &lt; score &lt;= max  可以使用小括号， 即 (min max,   如果想表达无限， 使用负无穷 -inf， 正无穷+inf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回指定分数范围成员个数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定排名内的升序元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyrank key start end</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定分数范围的成员</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="集合间的操作"><a href="#集合间的操作" class="headerlink" title="集合间的操作"></a>集合间的操作</h3><ol>
<li><p>交集</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zinterstore destination numkeys key [key ...] [weights weight [weight ...]]  [aggregate sum | min | max]</span><br><span class="line"></span><br><span class="line"><span class="comment"># destination 交集计算结果保存到这个键</span></span><br><span class="line"><span class="comment"># numkeys 需要做交集计算键的个数</span></span><br><span class="line"><span class="comment"># key [key ...]</span></span><br><span class="line"><span class="comment"># weights weight [weight ...] 每个键的权重，在做交集计算时，每个键中的每个member会将自己分数乘以这个权重， 每个键的权重默认是1</span></span><br><span class="line"><span class="comment"># aggregate sum | min | max  :计算成员交集后，分值可以按照sum， min， max做汇总，默认值是sum</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>并集</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zunionstore destination numkeys key [key ... ] [weights weight [weight ...]] [ aggregate sum|min|max ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令参数与zinsertstore一致</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="HyperLogLog命令"><a href="#HyperLogLog命令" class="headerlink" title="HyperLogLog命令"></a>HyperLogLog命令</h2><p>HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的，并且很小很小，只需要12KB内存就可以计算接近2^64个不同元素的基数，但是HyperLogLog只能依据输入的元素算出基数，而不能向set一样输出</p>
<ol>
<li><p>添加基数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果HyperLogLog更改了就返回1 否则返回0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回近似基数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pfcount key [key ...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的基数并不是精确值， 而是一个带有0.81%标准错误，所以这个只能返回近似值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>合并HyperLogLog</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并后保存的名称  sourcekey需要合并的key</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p><a href="https://jijiking51.cn/2019/08/23/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">redis主从复制</a></p>
<h1 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h1><h2 id="redis的持久化rdb和aof的方式"><a href="#redis的持久化rdb和aof的方式" class="headerlink" title="redis的持久化rdb和aof的方式"></a>redis的持久化rdb和aof的方式</h2><h3 id="各自怎么配置开启"><a href="#各自怎么配置开启" class="headerlink" title="各自怎么配置开启"></a>各自怎么配置开启</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">dbfilename xxxx</span><br><span class="line"></span><br><span class="line"># 分别表示</span><br><span class="line">每900秒进行了1次修改操作则进行RDB快照保存</span><br><span class="line">每300秒进行了10次修改操作则进行RDB快照保存</span><br><span class="line">每60秒进行了10000次修改操作则进行RDB快照保存</span><br><span class="line"></span><br><span class="line">保存的名称为xxxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># RDB没有载入命令， 服务器启动时检测到有RDB文件就会自动载入</span><br><span class="line"># 载入时日志输出 DB loaded from disk：....</span><br></pre></td></tr></table></figure>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfilename xxxx</span><br><span class="line"></span><br><span class="line"># 第一个参数表示开启AOF</span><br><span class="line"># 第二个参数表示AOF文件的名称</span><br><span class="line"># AOF保存的路径和dir配置的一致。</span><br><span class="line"></span><br><span class="line"># 因为AOF文件更新频率通常比RDB文件的更新频率高，所以如果服务器开启了AOF持久化功能，那么服务器就会优先使用AOF文件来还原数据库数据</span><br><span class="line"># 只有在AOF持久化功能关闭状态时，服务器才会使用RDB文件来还原数据库状态</span><br></pre></td></tr></table></figure>
<div id="flowchart-0" class="flow-chart"></div>



<h3 id="各自的特点是什么，持久化的过程"><a href="#各自的特点是什么，持久化的过程" class="headerlink" title="各自的特点是什么，持久化的过程"></a>各自的特点是什么，持久化的过程</h3><h4 id="RDB-1"><a href="#RDB-1" class="headerlink" title="RDB"></a>RDB</h4><h5 id="持久化流程"><a href="#持久化流程" class="headerlink" title="持久化流程"></a>持久化流程</h5><pre class="mermaid">graph TB
A(bgsave) -->|1| B(父进程)
B-->C(有其他子进程正在执行,直接返回)
style C fill:#cec,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5;
B-->H(BGREWRITEAOF正在执行,拒绝此次BGSVE)
style H fill:#dec,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5;
B-->|2| D(fork)
D--> E(子进程)
D -->|3| F((响应其他命令))
E -->|4| G(生成RDB文件)
E-->|5信号通知父进程| B
I(发送BGREWRITEAOF命令)-->|冲突命令|F
F-->|冲突解决|J(BGSAVE命令结束后再继续执行BGREWRITEAOF)</pre>

<ol>
<li>如果已经存在RDB/AOF子进程则直接返回</li>
<li>fork过程父进程会阻塞，通过info stats命令查看<code>latest_fork_usec</code>可以看到最近一次fork耗时多少微秒</li>
<li>fork完成后会返回<code>Background saving started</code>信息，并不在阻塞</li>
<li>创建RDB文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。执行lastsave命令可以得到上次生成RDB的时间，对应<code>Info Persistence命令中的rdb_last_save_time参数</code></li>
<li>进程发送信号给父进程表示完成， 父进程更新<code>info Persistence 关于rdb_*</code>的统计信息</li>
</ol>
<h5 id="文件的处理"><a href="#文件的处理" class="headerlink" title="文件的处理"></a>文件的处理</h5><p>RDB文件保存在dir配置指定的目录下，文件名和dbfilename配置相同，可以通过<code>config set dir{newDir} / config set dbfilename {newFileName}</code>在运行期间动态更新配置。</p>
<p>RDB文件默认使用LZF算法进行压缩，压缩后的文件大小远远小于内存中的大小，可以通过修改<code>rdbcompression</code>参数修改，或者执行命令<code>config set rdbcompression {yes|no}</code>动态修改</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p>
<ol>
<li>是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照，适用于备份， 全量复制等场景</li>
<li>加载RDB恢复的速度远远快于AOF</li>
</ol>
<p>缺点：</p>
<ol>
<li>没有办法做到实时持久化\秒级持久化。因为bgsave每次运行都要fork子进程，频繁操作成本过高</li>
<li>RDB文件使用二进制格式保存，Redis版本演进过程中有多个redis格式版本，存在新老版本不兼容问题</li>
</ol>
<h5 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|REDIS|db_version|databases|EOF|check_sum|</span><br><span class="line"></span><br><span class="line">REDIS:长度为5字节的‘REDIS’五个字符，用于快速检查所有载入的文件是否RDB文件</span><br><span class="line">db_version:长度为4字节，他的值是一个字符串表示的整数，这个是整数记录了RDB文件的版本号，比如0006，就代表RDB文件的版本为第六版</span><br><span class="line">databases：包含着0个或者任意多个数据库，以及各个数据库中的键值对数据</span><br><span class="line">	如果服务器数据库状态为空，那么这个部分也为空，长度为0字节</span><br><span class="line">	如果服务器有至少一个数据库非空，那么这个部分也非空，根据数据库所保存键值对的数量，类型和内容不同， 这个部分的长度也有所不同</span><br><span class="line">EOF：常量的长度为1字节，这个常量标志者RDB文件正文内容的借书，当读入程序遇到这个值的时候他知道所有数据库的所有键值对都已经载入完毕了</span><br><span class="line">check_sum:是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS，db_version, databases,EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将再如数据所计算出的校验与check_sum所记录的校验和进行对比，以此来检测是否有出错或者损坏情况</span><br></pre></td></tr></table></figure>
<h6 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h6><p>如果一个数据库0/3非空，那么服务器将创建一个以下结构的RDB文件</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|REDIS|db_version|database 0|database 3|EOF|check_sum|</span><br></pre></td></tr></table></figure>
<p>每个databases部分都是以下三个部分</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|SELECTDB | db_number | key_value_pairs|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECTDB: 常亮长度为1字节，当读入程序遇到这个值的时候知道接下来要读入的将是一个数据库号码</span><br><span class="line">db_number: 保存者一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节，2字节，5字节。当程序读入db_number部分之后，服务器会调用select命令根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中</span><br><span class="line">key_value_pairs: 部分保存了数据库中所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起，根据键值对的数量、类型、内容、以及是否过期等条件不同，key_value_pairs部分的长度也会有所不同</span><br><span class="line"></span><br><span class="line">所以上面这个例子的结构又可以是</span><br><span class="line">|REDIS|db_version|SELECTDB | 0 | key_value_pairs|SELECTDB | 3 | key_value_pairs|EOF|check_sum|</span><br></pre></td></tr></table></figure>
<h6 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h6><p>key_value_pairs结构</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">不带过期时间的键值对</span><br><span class="line">|TYPE|KEY|VALUE|</span><br><span class="line"></span><br><span class="line">TYPE：</span><br><span class="line">	REDIS_RDB_TYPE_STRING</span><br><span class="line">	REDIS_RDB_TYPE_LIST</span><br><span class="line">	REDIS_RDB_TYPE_SET</span><br><span class="line">	REDIS_RDB_TYPE_ZSET</span><br><span class="line">	REDIS_RDB_TYPE_HASH</span><br><span class="line">	REDIS_RDB_TYPE_LIST_ZIPLIST</span><br><span class="line">	REDIS_RDB_TYPE_SET_INTSET</span><br><span class="line">	REDIS_RDB_TYPE_ZSET_ZIPLIST</span><br><span class="line">	REDIS_RDB_TYPE_HASH_ZIPLIST</span><br><span class="line">KEY: 是一个字符串对象，编码方式和REDIS_RDB_TYPE_STRING类型的value一样，根据内容长度不同， key长度也有所不同</span><br><span class="line">VALUE：根据保存的结构不同， 保存的形式和长度都会有所不同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">带有过期时间的键值对</span><br><span class="line">|EXPIRETIME_MS|ms|TYPE|KEY|VALUE|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPIRETIME_MS: 常量长度，告知读入程序接下来读入的将是一个以毫秒为单位的过期时间</span><br><span class="line">ms:是一个8字节的带符号整数，记录一个以毫秒为单位的unix时间戳，这个时间戳是这个键的过期时间</span><br></pre></td></tr></table></figure>
<h6 id="value编码"><a href="#value编码" class="headerlink" title="value编码"></a>value编码</h6><p>每个value部分都保存了一个值对象, 根据TYPE不同，value部分的结构长度也不同</p>
<p><a href="#jump1">REDIS_ENCODING_*编码</a></p>
<ol>
<li><p>字符串对象</p>
<p>如果TYPE的值为REDIS_RDB_TYPE_STRING, 那么value保存的就是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT, REDIS_ENCODING_RAW。</p>
<p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数，这种编码的对象以以下格式保存</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|ENCODING|content|</span><br><span class="line"></span><br><span class="line"># 例如 用8位保存的整数123</span><br><span class="line">| REDIS_RDB_ENC_INT8 | 123 |</span><br></pre></td></tr></table></figure>
<p>如果字符串编码为REDIS_ENCODING_RAW，那么说明保存的是一个字符串，根据长度不同，有压缩和不压缩两种方式保存（手动关闭压缩选项情况除外）</p>
<ul>
<li>如果字符串的长度小于20字节，那么这个字符串将原样保存</li>
<li>如果这个字符串长度大于20字节， 那么这个字符串会被压缩保存</li>
</ul>
<p>如果没有被压缩将以下格式保存</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| len | string |</span><br><span class="line"></span><br><span class="line">#  例如 ”hello“</span><br><span class="line">| 5 | hello |</span><br></pre></td></tr></table></figure>
<p>如果压缩后将按照以下格式保存</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">| REDIS_RDB_ENC_LZF | compressed_len | orgin_len | compressed_string |</span><br><span class="line"></span><br><span class="line">REDIS_RDB_ENC_LZF:标志字符串已经被LZF算法压缩过了</span><br><span class="line">compressed_len：被压缩之后长度</span><br><span class="line">orgin_len：原来的长度</span><br><span class="line">compressed_string： 被压缩后的字符串内容</span><br><span class="line"></span><br><span class="line"># 例如</span><br><span class="line">| REDIS_RDB_ENC_LZF | 6 | 21 | ?aa??? |</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表对象</p>
<p>如果TYPE的值是REDIS_RDB_TYPE_LIST，那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，RDB文件保存这种对象的结构</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| list_length | item1 | item2 | ... | itemn|</span><br><span class="line"></span><br><span class="line"># list_length记录了列表的长度， 记录列表item的个数</span><br><span class="line"># 因为item项都是字符串对象，所以程序会以处理字符串对象的方式来保存读入列表项</span><br><span class="line"></span><br><span class="line"># 示例 一个list中有三个项 hello world ！</span><br><span class="line">|3|5|hello|5|world|1|!|</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合对象</p>
<p>当TYPE为REDIS_RDB_TYPE_SET，那么value保存的就是一个REDIS_ENCODING_HT编码的集合对象，RDB文件保存这种对象结构图</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| set_size | elem1 | elem2 | ... | elemN |</span><br><span class="line"></span><br><span class="line">set_size:表示集合的大小，记录了有多少个elem对象</span><br><span class="line">elem：表示集合元素，因为每个集合元素都是一个字符串对象，所以程序会以处理字符串对象的方式来保存和读入集合元素</span><br><span class="line"></span><br><span class="line"># 示例 集合中有四个对象  apple  banana cat dog</span><br><span class="line">| 4 | 5 | apple | 6 | banana | 3 | cat | 3 | dog |</span><br></pre></td></tr></table></figure>
</li>
<li><p>哈希表对象</p>
<p>当TYPE为REDIS_RDB_TYPE_HASH, 那么value保存的就是一个REDIS_ENCODING_HT, 结构如下</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">| hash_size | key_value_pair 1 | key_value_pair 2 | ... | key_value_pair n |</span><br><span class="line"></span><br><span class="line">hash_size: 记录了哈希表的大小</span><br><span class="line">key_value_pair： 开头部分代表哈希表中的键值对，键值对都是字符串对象，所以程序会已处理字符串对象的方式来保存和读入键值对</span><br><span class="line"></span><br><span class="line">key_value_pair：存储格式 |key1|value1|key2|value2|...|keyn|valuen|</span><br><span class="line"></span><br><span class="line"># 示例 两个键值对  a apple        b banana</span><br><span class="line">| 2 | 1 | a | 5 | apple | 1 | b | 6 | bannana |</span><br></pre></td></tr></table></figure>
</li>
<li><p>有序集合对象</p>
<p>当TYPE为REDIS_RDB_TYPE_ZSET，那么value保存的就是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象， 结构如下</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">| sorted_set_size | element1 | element2 | ... | elementN | </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sorted_set_size:记录有序集合数量</span><br><span class="line">element： 分成两个部分， 一个为score， 另一个member， memeber是一个字符串对象，score是一个double类型的浮点数，但是程序会在转换的时候将double转换成字符串对象， 然后再用保存字符串对象的方法将score和member保存起来</span><br><span class="line"></span><br><span class="line">| sorted_set_size | member1 | score1 | member2 | score2 | ... | memberN | scoreN | </span><br><span class="line"></span><br><span class="line"># 示例 有序集合含有两个对象 pi 3.14       e 2.7</span><br><span class="line">| 2 | 2 | pi | 4 | 3.14 | 1 | e | 3 | 2.7 |</span><br></pre></td></tr></table></figure>
</li>
<li><p>INTSET编码集合</p>
<p>如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET, 那么value保存的就是一个整<br>数集合对象.RDB文件保存这种对象的方法是,先将整数集合转换为宇符串对象，然后将<br>这个字符串对象保存到RDB文件里面。<br>如果程序在读入RDB文件的过程中，碰到由整数集合对象转换成的宇符串对象，那么<br>程序会根据TYPE值的指示.先读人字符串对象，再将这个宇符串对象转换成原来的整数集<br>合对象。</p>
</li>
<li><p>ZIPLIST编码的列表、哈希表或者有序集合<br>如果 TYPE 的值为 REDIS_RDB_TYPE_LIST_ZIPLIST、 REDIS_RDB_TYPE_HASH _ZIPLIST 或者 REDIS_RDB_TYPE_SET_ZIPLIST,那么 value 保存的就是一个压縮列表对象，RDB文件保存这种对象的方法是：</p>
<ol>
<li>将压缩列表转换成一个宇符串对象。</li>
<li>将转换所得的字符串对象保存到RDB文件。</li>
</ol>
<p>如果程序在读人RDB文件的过程中，碰到由任缩列表对象转换成的宇符串对象，那么<br>程序会根据TYPE值的指示，执行以下操作：</p>
<ol>
<li>读入字符串对象，并将它转换成原来的压缩列表对象</li>
<li>根据TYPE的值，设置压缩列表对象的类型：如果TYPE的值为REDIS_RDB_ TXPE_LIST_ZIPLIST,那么压缩列表对象的类型为列表 ；如果TYPE的值为REDIS _ RDB_TYPE_HASH_ZIPLIST,那么压缩列表对象的类型为哈希表；如果TYPE的值为 REDIS_RDB_TYPE_ZSET_ZIPLIST,那么压缩列表对象的类型为有序集合。</li>
</ol>
<p>从步骤2可以看出，由于TYPE的存在，即使列表 、哈希表和有序集合三种类型都使用<br>压缩列表来保存，RDB读入程序也总可以将读入并转换之后得出的压缩列表设置成原来的类型。</p>
</li>
</ol>
<h4 id="AOF-1"><a href="#AOF-1" class="headerlink" title="AOF"></a>AOF</h4><h5 id="持久化流程-1"><a href="#持久化流程-1" class="headerlink" title="持久化流程"></a>持久化流程</h5><pre class="mermaid">graph TB
A(命令写入) -->|1.append| B(AOF缓冲)
B-->|2.sync|C(AOF文件)
C-->|3.rewrite|C
D(重启)-->|4.load|C</pre>

<ol>
<li>所有的写入命令会追加到<code>aof_buf（缓冲区)</code></li>
<li>AOF缓冲区根据对应的策略向硬盘做同步操作</li>
<li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的</li>
<li>当redis服务器重启时，可以加载AOF文件进行数据恢复</li>
</ol>
<p>AOF持久化可以分为追加， 文件写入，文件同步</p>
<h5 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h5><p>当aof打开时，服务器执行完一次写命令后会以协议格式将被执行的写命令追加到服务器的aof_buf缓冲区的末尾</p>
<blockquote>
<p>redis&gt; SET KEY VALUE</p>
<p>执行set命令后， 会将内容根据协议追加到aof_buf末尾</p>
<p>*3\r\n$3\r\nSET\r\n$3\r\n$5\r\nVALUE\r\n</p>
</blockquote>
<h5 id="写入与同步"><a href="#写入与同步" class="headerlink" title="写入与同步"></a>写入与同步</h5><p>redis服务器进程就是一个事件循环，循环中的文件时间负责接收客户端的命令请求以及向客户端发送命令回复，在这些请求中可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环前都会考虑<a href="#jump2">根据appendfsync配置</a>是否需要将aof_buf缓冲区的内容写入和保存到AOF文件里面</p>
<h5 id="载入与还原"><a href="#载入与还原" class="headerlink" title="载入与还原"></a>载入与还原</h5><ol>
<li>建立不带网络的伪客户端(reids命令只能在客户端执行，而AOF命令来自文件而不是网路)</li>
<li>从AOF文件中分析并读取出一条写命令</li>
<li>使用伪客户端执行被读出的写命令</li>
<li>重复2、3步骤，直到AOF文件中的所有写命令都被处理完毕</li>
</ol>
<h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 执行</span><br><span class="line">rpush list "a" "b"</span><br><span class="line">rpush list "c"</span><br><span class="line">rpush list "d" "e"</span><br><span class="line">lpop list</span><br><span class="line">lpop list</span><br><span class="line">rpush list "f" "g"</span><br><span class="line"># 第一次保存后，list的信息保存了6条</span><br><span class="line"></span><br><span class="line"># 重写后可以压缩为</span><br><span class="line">rpush list "c" "D" "E" "F" "G"</span><br><span class="line">这样就可以用一条命令替代上面的6条命令</span><br></pre></td></tr></table></figure>
<div id="flowchart-1" class="flow-chart"></div>

<blockquote>
<p>为了避免在执行命令时造成客户端缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合、这四种可能存在多个元素的键时，会先检查元素的个数，如果超过了REDIS_AOF_REWRITE_ITEMS_CMD（默认64）常量的值，那么会分多条命令写入</p>
</blockquote>
<h5 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h5><ol>
<li>父进程创建子进程，并且由子进程进行AOF重写</li>
<li>子进程重写期间，父进程的写命令会发送给AOF缓冲区和AOF重写缓冲区</li>
<li>子进程重写完毕后会发送信号给父进程</li>
<li>父进程接收到信号后将AOF重写缓冲区中的所有内容写入到新AOF中</li>
<li>对新AOF文件进行改名，原子的覆盖现有的AOF文件，完成新旧两个AOF文件替换</li>
</ol>
<p>整个流程中只有型号处理的时候父进程会造成阻塞。</p>
<h3 id="rdb和aof持久化和写盘的触发机制设置，-手动触发持久化的方法"><a href="#rdb和aof持久化和写盘的触发机制设置，-手动触发持久化的方法" class="headerlink" title="rdb和aof持久化和写盘的触发机制设置，  手动触发持久化的方法"></a>rdb和aof持久化和写盘的触发机制设置，  手动触发持久化的方法</h3><h4 id="RDB-2"><a href="#RDB-2" class="headerlink" title="RDB"></a>RDB</h4><p>手动触发命令：<strong>save</strong>和<strong>bgsave</strong></p>
<ul>
<li><p>save：阻塞当前Redis服务器，直到RDB过程完成位置，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用，save命令对应的Redis日志</p>
<blockquote>
<p>DB saved on disk</p>
</blockquote>
</li>
<li><p>bgsave：Redis进程fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。运行bgsave命令对应的Redis日志</p>
<blockquote>
<p>Background saving started by pid xxxx </p>
<p>DB saved on disk</p>
<p>RDB: 0 MB of memory used by copy-on-write</p>
<p>Background saving terminated with success</p>
</blockquote>
</li>
</ul>
<p>自动触发RDB机制</p>
<ul>
<li>使用save相关配置<code>save m n</code> ,在m秒内数据集存在n次修改时，自动触发bgsave</li>
<li>从节点执行全量复制操作，主节点自动执行bgsave生成RDB</li>
<li>执行debug reload命令重新加载redis时会自动触发save操作</li>
<li>默认情况下执行shutdown命令时， 如果没有开启AOF持久化功能，则自动执行bgsave</li>
</ul>
<h5 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h5><p>在redisServer结构中saveparams属性保存了条件数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">//保存条件数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个saveparam结构保存了一个save选项设置的条件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改量</span></span><br><span class="line">    <span class="keyword">int</span> changes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="记录属性"><a href="#记录属性" class="headerlink" title="记录属性"></a>记录属性</h5><p>除此之外，还维护了一个<code>dirty</code>计数器，以及一个<code>lastsave</code>属性</p>
<ul>
<li>dirty计数器记录距离上一次成功执行save命令或者bgsave命令之后服务器对数据库状态进行了多少次修改</li>
<li>lastsave属性是一个unix时间戳，记录了服务器上一次成功执行save命令或者bgsave命令时间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改计数器 每次成功执行一个数据库修改命令后程序就会对dirty计数器进行更新</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="检查条件是否满足"><a href="#检查条件是否满足" class="headerlink" title="检查条件是否满足"></a>检查条件是否满足</h5><p>redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，他的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足就会执行bgsave命令</p>
<h4 id="AOF-2"><a href="#AOF-2" class="headerlink" title="AOF"></a>AOF</h4><h5 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h5><p>AOF缓冲区同步文件策略由参数<code>appendfsync</code>控制</p>
<p><span id="jump2"></span></p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">always</td>
<td style="text-align:center">命令写入aof_buf后调用系统fsync操作同步到AOF文件，fsync完成后线程返回，一旦配置这个，redis只能支持几百TPS，与redis高性能背道而驰，不建议配置</td>
</tr>
<tr>
<td style="text-align:center">everysec</td>
<td style="text-align:center">命令写入aof_buf后调用系统write操作，write完成后线程返回。fsync同步文件操作由专门线程每秒调用一次，默认配置，做到兼顾性能和数据安全性，理论上只有在系统突然宕机的情况下丢失1秒数据</td>
</tr>
<tr>
<td style="text-align:center">no</td>
<td style="text-align:center">命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步， 同步硬盘操作由操作系统负责，通常同步周期最长30秒。由于操作系统每次同步AOF文件的周期不可控，每次同步硬盘的数据量会很大，虽然提升了性能，但是数据安全性无法保证</td>
</tr>
</tbody>
</table>
<ul>
<li>write：触发延迟写机制。Linux在内核提供页缓冲区来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制。文件同步之前如果系统故障宕机，缓冲区内数据丢失</li>
<li>fsync：正对单个文件操作（AOF文件），做强制硬盘同步，fsync将阻塞直到写入硬盘完成后返回，保证了数据持久化</li>
</ul>
<h5 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h5><ul>
<li><p>手动触发：<code>BGREWRITEAOF</code></p>
</li>
<li><p>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机</p>
<p>触发时机=aof_current_size &gt; auto-aof-rewrite-min-size &amp;&amp; (aof_current_size - aof_base_size) / aof_base_size &gt;=auto-aof-rewrite-percentage</p>
<ul>
<li>auto-aof-rewrite-min-size：标识运行AOF重写时文件最小体积，默认64MB</li>
<li>auto-aof-rewrite-percentage：代表当前AOF文件空间和上一次重写后AOF文件空间的比值</li>
<li>aof_current_size: 目前aof文件大小</li>
<li>aof_base_size: 上次的大小</li>
</ul>
<pre class="mermaid">  graph TD
1(bgrewriteaof)-->|1|2(父进程)
2-->|2|3(fork)
3-->4(子进程)
4-->|4.1 新号通知父进程|2
3-->|2.1|5(aof_buf)
3-->|2.2|6(aof_rewrite_buf)
6-->|4.2|7(新AOF文件)
4-->|3|7
5-->8(旧AOF文件)
7-->|4.3|8</pre>

<ol>
<li>执行AOF重写请求，如果当前进程正在执行AOF重写，请求不执行并返回错误，如果正在执行bgsave，重写命令延迟到bgsave完成后再执行</li>
<li>父进程fork创建子进程，开销等同于bgsave过程<ol>
<li>主进程fork操作完成后，继续响应其他命令。所有修改命令依然写入AOF缓冲区并根据appendfsync策略同步到硬盘，保证原有AOF机制正确性</li>
<li>由于fork操作运用写时复制技术，子进程只能共享fork操作时的内存数据。由于父进程依然响应命令，Redis使用<code>AOF重写缓冲区</code>保存这部分新数据，防止新AOF文件生成期间丢失这部分数据。</li>
</ol>
</li>
<li>子进程根据内存快照，按照命令合并规则写入到新的AOF文件。每次批量写入硬盘数据量由配置aof-rewrite-incremental-fsync控制，默认为32MB，防止单次刷盘数据过多造成硬盘阻塞</li>
<li><ol>
<li>新AOF文件写入完成后，子进程发送信号给父进程，父进程更新统计信息，具体见<code>info persistence</code>下的aof_*相关统计。</li>
<li>父进程把AOF重写缓冲区的数据写入到新的AOF文件。</li>
<li>使用新AOF文件替换老文件，完成AOF重写。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="AOF载入流程"><a href="#AOF载入流程" class="headerlink" title="AOF载入流程"></a>AOF载入流程</h5><div id="flowchart-2" class="flow-chart"></div>





<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><ul>
<li><p>开启RDB和AOF持久化方式</p>
</li>
<li><p>创建定时任务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建定时任务</span></span><br><span class="line">crontab -e</span><br><span class="line"><span class="comment"># 设置每个小时将RDB文件备份到另外一个文件夹</span></span><br><span class="line">0 1 * * * cp /your dump.rdb  path ~/BACKUP/BACK_`date <span class="string">'+%Y%m%d_%H.%M.%S+'</span>`.rdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>定期清除过期快照</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加定时任务</span></span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个小时清除一次过期快照</span></span><br><span class="line">0 */1 * * * /bin/bash /your sh path/xxx.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># xxx.sh  清除48小时之前的快照</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 快照放置文件夹</span></span><br><span class="line">back_path=/path</span><br><span class="line"><span class="comment"># 设置48小时前时间名称</span></span><br><span class="line">content=$(date +%Y%m%d_%H --date <span class="string">'2 day ago'</span>)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$back_path</span></span><br><span class="line"><span class="comment"># 统计删除的文件数量</span></span><br><span class="line">FileNum=$(find -name <span class="string">"*<span class="variable">$content</span>*"</span>.rdb | wc -l)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"--clean file:<span class="variable">$(date +%Y%m%d_%H%M%S)</span>:<span class="variable">$FileNum</span>-----"</span></span><br><span class="line"><span class="comment"># 如果数量大于0，说明有文件需要删除</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$FileNum</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"delete [<span class="variable">$content</span>]"</span></span><br><span class="line">    <span class="comment"># 通过通配符删除</span></span><br><span class="line">    rm -rf ./*<span class="variable">$content</span>*</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一天一次将备份数据文件备份到redis服务器之外的机器上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /path xxx@Ip:/path</span><br></pre></td></tr></table></figure>
<p><script src="https://cdn.bootcss.com/raphael/2.2.7/raphael.min.js"></script><script src="https://cdn.bootcss.com/flowchart/1.7.0/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始
op1=>operation: 服务器启动
op2=>operation: 执行在如程序
cond1=>condition: 已开启AOF持久化功能
op3=>operation: 载入AOF文件
op4=>operation: 载入RDB文件

st->op1->op2->cond1
cond1(yes)->op3
cond1(no)->op4</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">op1=>operation: 创建新AOF
cond1=>condition: 数据库全部遍历了？
cond2=>condition: 是否是空数据库
op2=>operation: 写入select命令，指定数据库号码
cond3=>condition: 已经遍历完所有的键？
cond4=>condition: 键已经过期？
op3=>operation: 根据键的类型对键进行重写，如果有过期时间，过期时间也要重写
op4=>operation: 写入完毕，关闭文件

op1->cond1
cond1(no)->cond2
cond2(no)->op2
op2->cond3
cond3(yes)->cond1
cond3(no)->op3
op3->cond3
cond2(yes)->cond1
cond1(yes)->op4</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">op1=>operation: redis启动 
op2=>operation: 加载RDB
op3=>operation: 加载AOF
op4=>operation: 启动成功
op5=>operation: 启动失败


cond1=>condition: 开启AOF？
cond2=>condition: 存在AOF？
cond3=>condition: 存在RDB？
cond4=>condition: 成功？

op1->cond1
cond1(no)->cond3
cond1(yes)->cond2
cond2(no)->cond3
cond2(yes)->op3
cond3(no)->op4
cond3(yes)->op2
op2->cond4
op3->cond4
cond4(yes)->op4
cond4(no)->op5</textarea><textarea id="flowchart-2-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script></p>
</li>
</ul>

    </div>


    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/学习记录/" rel="tag"><i class="fa fa-tag"></i> 学习记录</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/08/19/mysql学习笔记/" rel="next" title="mysql学习笔记">
                  <i class="fa fa-chevron-left"></i> mysql学习笔记
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/08/20/ubuntu修改为阿里云镜像源/" rel="prev" title="ubuntu修改为阿里云镜像源">
                  ubuntu修改为阿里云镜像源 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
    
    
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="RocWong">
  <p class="site-author-name" itemprop="name">RocWong</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



          
        </div>
        <div>
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=200 height=52 src="//music.163.com/outchain/player?type=0&id=2945061139&auto=1&height=32"></iframe>
        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一天"><span class="nav-number">1.</span> <span class="nav-text">第一天</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#了解redis的数据库，了解相似的缓存数据库，redis的局限"><span class="nav-number">1.1.</span> <span class="nav-text">了解redis的数据库，了解相似的缓存数据库，redis的局限</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis数据库"><span class="nav-number">1.1.1.</span> <span class="nav-text">redis数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相似类型数据库对比"><span class="nav-number">1.1.2.</span> <span class="nav-text">相似类型数据库对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis对比其他数据库优势"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">redis对比其他数据库优势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis用途"><span class="nav-number">1.1.3.</span> <span class="nav-text">redis用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis局限"><span class="nav-number">1.1.4.</span> <span class="nav-text">redis局限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出一个redis实例的linux环境安装文档，包括安装步骤，配置，启动关闭等"><span class="nav-number">1.2.</span> <span class="nav-text">输出一个redis实例的linux环境安装文档，包括安装步骤，配置，启动关闭等</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装流程"><span class="nav-number">1.2.1.</span> <span class="nav-text">安装流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置文件翻译"><span class="nav-number">1.2.2.</span> <span class="nav-text">配置文件翻译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动与关闭redis"><span class="nav-number">1.2.3.</span> <span class="nav-text">启动与关闭redis</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二天"><span class="nav-number">2.</span> <span class="nav-text">第二天</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#全局命令"><span class="nav-number">2.1.</span> <span class="nav-text">全局命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串命令"><span class="nav-number">2.2.</span> <span class="nav-text">字符串命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希"><span class="nav-number">2.3.</span> <span class="nav-text">哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表"><span class="nav-number">2.4.</span> <span class="nav-text">列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加操作"><span class="nav-number">2.4.1.</span> <span class="nav-text">添加操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找"><span class="nav-number">2.4.2.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除"><span class="nav-number">2.4.3.</span> <span class="nav-text">删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改"><span class="nav-number">2.4.4.</span> <span class="nav-text">修改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">2.5.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集合内操作"><span class="nav-number">2.5.1.</span> <span class="nav-text">集合内操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合间操作"><span class="nav-number">2.5.2.</span> <span class="nav-text">集合间操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序集合"><span class="nav-number">2.6.</span> <span class="nav-text">有序集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集合内"><span class="nav-number">2.6.1.</span> <span class="nav-text">集合内</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合间的操作"><span class="nav-number">2.6.2.</span> <span class="nav-text">集合间的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HyperLogLog命令"><span class="nav-number">2.7.</span> <span class="nav-text">HyperLogLog命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三天"><span class="nav-number">3.</span> <span class="nav-text">第三天</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#复制原理"><span class="nav-number">3.1.</span> <span class="nav-text">复制原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四天"><span class="nav-number">4.</span> <span class="nav-text">第四天</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redis的持久化rdb和aof的方式"><span class="nav-number">4.1.</span> <span class="nav-text">redis的持久化rdb和aof的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#各自怎么配置开启"><span class="nav-number">4.1.1.</span> <span class="nav-text">各自怎么配置开启</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">RDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">AOF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#各自的特点是什么，持久化的过程"><span class="nav-number">4.1.2.</span> <span class="nav-text">各自的特点是什么，持久化的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB-1"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#持久化流程"><span class="nav-number">4.1.2.1.1.</span> <span class="nav-text">持久化流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文件的处理"><span class="nav-number">4.1.2.1.2.</span> <span class="nav-text">文件的处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优缺点"><span class="nav-number">4.1.2.1.3.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDB文件结构"><span class="nav-number">4.1.2.1.4.</span> <span class="nav-text">RDB文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#databases部分"><span class="nav-number">4.1.2.1.4.1.</span> <span class="nav-text">databases部分</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#key-value-pairs部分"><span class="nav-number">4.1.2.1.4.2.</span> <span class="nav-text">key_value_pairs部分</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#value编码"><span class="nav-number">4.1.2.1.4.3.</span> <span class="nav-text">value编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF-1"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#持久化流程-1"><span class="nav-number">4.1.2.2.1.</span> <span class="nav-text">持久化流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#追加"><span class="nav-number">4.1.2.2.2.</span> <span class="nav-text">追加</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#写入与同步"><span class="nav-number">4.1.2.2.3.</span> <span class="nav-text">写入与同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#载入与还原"><span class="nav-number">4.1.2.2.4.</span> <span class="nav-text">载入与还原</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重写"><span class="nav-number">4.1.2.2.5.</span> <span class="nav-text">重写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOF后台重写"><span class="nav-number">4.1.2.2.6.</span> <span class="nav-text">AOF后台重写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdb和aof持久化和写盘的触发机制设置，-手动触发持久化的方法"><span class="nav-number">4.1.3.</span> <span class="nav-text">rdb和aof持久化和写盘的触发机制设置，  手动触发持久化的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB-2"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#设置保存条件"><span class="nav-number">4.1.3.1.1.</span> <span class="nav-text">设置保存条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#记录属性"><span class="nav-number">4.1.3.1.2.</span> <span class="nav-text">记录属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#检查条件是否满足"><span class="nav-number">4.1.3.1.3.</span> <span class="nav-text">检查条件是否满足</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF-2"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文件同步"><span class="nav-number">4.1.3.2.1.</span> <span class="nav-text">文件同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重写机制"><span class="nav-number">4.1.3.2.2.</span> <span class="nav-text">重写机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOF载入流程"><span class="nav-number">4.1.3.2.3.</span> <span class="nav-text">AOF载入流程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#备份"><span class="nav-number">4.2.</span> <span class="nav-text">备份</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer">
  </div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RocWong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        <span>0%</span>
      </div>
      <div class="reading-progress-bar"></div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>

<script src="/js/schemes/pisces.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>





  
  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
              leancloudSelector(url).innerText = counter.time + 1;
            
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
            
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.url;
            var time = item.time;
            leancloudSelector(url).innerText = time;
          }
          for (var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=akQ7J933kSkT6bS8EGY4mz1S-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'akQ7J933kSkT6bS8EGY4mz1S-gzGzoHsz',
            'X-LC-Key': 'Nzpwf4hnsjlU9jOzMC0HmReR',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        const localhost = /http:\/\/(localhost|127.0.0.1|0.0.0.0)/;
        if (localhost.test(document.URL)) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>










  <script src="/js/local-search.js?v=7.3.0"></script>










<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>




  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script><script src="/js/post-details.js?v=7.3.0"></script>


<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://rocwong.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  function disqus_config() {
    this.page.url = "https://jijiking51.cn/2019/08/19/redis学习wiki/";
    this.page.identifier = "2019/08/19/redis学习wiki/";
    this.page.title = 'redis学习wiki';};
  function loadComments() {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://rocwong.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  }
    window.addEventListener('load', loadComments, false);
  
</script>

</body>
</html>
