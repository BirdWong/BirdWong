<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://rocwong.top').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":true},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: 'VLJFW5X9VK',
      apiKey: '713d262e9c2df9002156c12b851b8e57',
      indexName: 'blog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

<!-- google 广告   http://www.google.com/adsense -->
  <script data-ad-client="ca-pub-8966265724665848" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <meta name="description" content="SDS-动态字符串定义SDS定义于sds.h&#x2F;sds.c文件 1&#x2F;*2 *  这个版本中， 不同的字符串长度使用的都是同一个结构体，3 *  这样会造成一定的内存浪费4 *  version 3.05 *&#x2F;6 struct sdshdr &amp;#123;7    &#x2F;&#x2F; 字符串的长度 8    unsigned int len;9    &#x2F;&#x2F; 记录buf中未使用字节的数量10    unsigned i">
<meta name="keywords" content="源码">
<meta property="og:type" content="article">
<meta property="og:title" content="redis源码-sds">
<meta property="og:url" content="https:&#x2F;&#x2F;rocwong.top&#x2F;2019&#x2F;04&#x2F;15&#x2F;redis%E6%BA%90%E7%A0%81-sds&#x2F;index.html">
<meta property="og:site_name" content="RocWong">
<meta property="og:description" content="SDS-动态字符串定义SDS定义于sds.h&#x2F;sds.c文件 1&#x2F;*2 *  这个版本中， 不同的字符串长度使用的都是同一个结构体，3 *  这样会造成一定的内存浪费4 *  version 3.05 *&#x2F;6 struct sdshdr &amp;#123;7    &#x2F;&#x2F; 字符串的长度 8    unsigned int len;9    &#x2F;&#x2F; 记录buf中未使用字节的数量10    unsigned i">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50d7faffa3.png">
<meta property="og:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50e169b803.png">
<meta property="og:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50e23d7963.png">
<meta property="og:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50e28c1620.png">
<meta property="og:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50e29e04a2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50e329713a.png">
<meta property="og:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50e33eb3a4.png">
<meta property="og:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50e3578644.png">
<meta property="og:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50e3856487.png">
<meta property="og:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50e3cdec5b.png">
<meta property="og:updated_time" content="2019-11-24T05:43:25.408Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;img.jsuacm.cn&#x2F;2015-09-13_55f50d7faffa3.png">

<link rel="canonical" href="https://rocwong.top/2019/04/15/redis%E6%BA%90%E7%A0%81-sds/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>redis源码-sds | RocWong</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-148097669-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-148097669-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e30f4d88f73cfa8c61f49d129ee6ced8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">RocWong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">朝闻道，夕死可矣</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/birdwong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rocwong.top/2019/04/15/redis%E6%BA%90%E7%A0%81-sds/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="RocWong">
      <meta itemprop="description" content="人法地、地法天、天法道、道法自然">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RocWong">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          redis源码-sds
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-15 17:15:22" itemprop="dateCreated datePublished" datetime="2019-04-15T17:15:22+08:00">2019-04-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/04/15/redis%E6%BA%90%E7%A0%81-sds/" class="post-meta-item leancloud_visitors" data-flag-title="redis源码-sds" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/15/redis%E6%BA%90%E7%A0%81-sds/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/15/redis%E6%BA%90%E7%A0%81-sds/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>43k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:19</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="SDS-动态字符串定义"><a href="#SDS-动态字符串定义" class="headerlink" title="SDS-动态字符串定义"></a>SDS-动态字符串定义</h1><p>SDS定义于<code>sds.h/sds.c</code>文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  这个版本中， 不同的字符串长度使用的都是同一个结构体，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  这样会造成一定的内存浪费</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  version 3.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 字符串的长度 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 记录buf中未使用字节的数量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> buf[];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 提供五种header定义，满足各种字符串大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * len：字符串的长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * alloc：字符串最大容量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * flags：标记header的类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * buf： 字节数组，用于保存字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * version 5.0 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> buf[];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> buf[];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> buf[];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> buf[];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> buf[];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>例如：<br>    目前：free=0、len=5、buf是一个char类型数组，我们向里面存入redis五个字符，则buf里面将会存入’r’,’e’,’d’,’i’,’s’,’\0’,最后一个是空字符，这个并不会被len所记录，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作都是SDS函数自动完成的，所以这个空字符对于SDS的使用者是完全透明的，这个空字符对于但是却很重要，关系到我们重用C字符串函数库里面的函数</p>
<p><img alt="结构图" data-src="http://img.jsuacm.cn/2015-09-13_55f50d7faffa3.png"></p>
<h1 id="SDS与C的字符串区别"><a href="#SDS与C的字符串区别" class="headerlink" title="SDS与C的字符串区别"></a>SDS与C的字符串区别</h1><h2 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h2><p>场景：<br>C字符串长度为N，则需要N+1长度数组存储（最后一位存空字符），现在需要获取字符串长度需要的复杂度是多少？<br>答案：O(n)， 过程是我们遍历整个字符串，对每个字符进行计数，直到遇到代表字符串结尾的空字符。</p>
<p><img alt="遍历示例" data-src="http://img.jsuacm.cn/2015-09-13_55f50e169b803.png"></p>
<p>如果是SDS呢，那么我们的时间复杂度是O(1),因为我们的len属性中记录了SDS本身的长度。</p>
<p><img alt="SDS获取长度" data-src="http://img.jsuacm.cn/2015-09-13_55f50e23d7963.png"></p>
<h2 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h2><p>除了获取字符串长度的复杂度搞之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出<br>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span></pre></td></tr></table></figure>
<p>我们将src字符串中的内容配接到dest字符串的末尾的时候，因为C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，如果上述条件不成立，则会产生缓冲区溢出</p>
<p>例如：程序中有两个在内存中紧邻的两个字符串s1,s2分别是’redis’,’mongodb’</p>
<p><img alt="内存中的状态" data-src="http://img.jsuacm.cn/2015-09-13_55f50e28c1620.png"></p>
<p>如果这个时候执行<code>strcat(s1,&quot; Cluster&quot;);</code>将s1中的内容修改为’Redis Cluster’，忘记为s1分配足够的空间，那么将会导致s2内容被意外地修改</p>
<p><img alt data-src="http://img.jsuacm.cn/2015-09-13_55f50e29e04a2.png"></p>
<hr>
<p>SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话API会自动将SDS的空间扩展至执行修改所需的大小，所以SDS不需要手动修改SDS的空间大小也不会出现缓冲区溢出问题。</p>
<h3 id="SDS空间分配策略"><a href="#SDS空间分配策略" class="headerlink" title="SDS空间分配策略"></a>SDS空间分配策略</h3><h4 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h4><p>前面说过，C字符串并不记录自身的长度，对于包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组，所以每次增长或者缩短一个C字符串都需要一次内存重分配。如果不重新分配会造成两种情况</p>
<ul>
<li><font color="#dd4b39">如果程序增长没有重新分配内存空间大小，会产生缓冲区溢出</font></li>
<li><font color="#dd4b39">如果缩短字符串操作没有重新分配空间，会产生内存泄漏</font></li>
</ul>
<h5 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h5><ul>
<li>如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。</li>
<li>如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte 。</li>
</ul>
<p>例如：</p>
<p><code>sdscat(s, &quot; Cluster&quot;);</code>,那么 sdscat 将执行一次内存重分配操作， 将 SDS 的长度修改为 13 字节， 并将 SDS 的未使用空间同样修改为 13 字节， </p>
<p><img alt="运行前内存示意图" data-src="http://img.jsuacm.cn/2015-09-13_55f50e329713a.png"><br><img alt="运行后内存示意图" data-src="http://img.jsuacm.cn/2015-09-13_55f50e33eb3a4.png"></p>
<p>如果这个时候我们再执行<code>sdscat(s, &quot; Tutorial&quot;);</code></p>
<p><img alt="运行示意图" data-src="http://img.jsuacm.cn/2015-09-13_55f50e3578644.png"></p>
<p>这是因为我们已经有13字节足以保存9字节的” Tutorial”,<br>在扩展 SDS 空间之前， SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配。</p>
<p>通过这种预分配策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。</p>
<h5 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h5><p>惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。<br>例如： S=”XYXXYabcXYY”，我们执行<code>sdstrim(s, &quot;XY&quot;);</code>移除S字符串中的所有 ‘X’ 和 ‘Y’。</p>
<p><img alt="执行后的示意图" data-src="http://img.jsuacm.cn/2015-09-13_55f50e3856487.png"></p>
<p>这个时候SDS并没有释放多出来的8个字节，而是将这8个字节空间保留在了SDS里面，如果之后对SDS进行增长操作的话，这些空间就能派上用场。</p>
<p>同时，SDS也提供了相应的API，让我们可以在有需要时真正的释放SDS里面的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>在C字符串中， 除了字符串末尾外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，所以不能用来保存二进制数据等一些特殊数据。<br>但是SDS使用buf保存二进制数据，特殊格式等对其无影响，因为SDS使用len属性的值而不是空字符串来判断字符串是否结束。</p>
<p><img alt="SDS保存非空字符结束" data-src="http://img.jsuacm.cn/2015-09-13_55f50e3cdec5b.png"></p>
<h4 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h4><p>SDS的API是二进制安全的，但它一样遵循C字符串以空字符结尾的惯例，这些API总会将SDS保存的数据的末尾设置为空字符，并且会为buf数组分配空一格字节的空间容纳这个空字符，这是为了让那些文本数据的SDS可以重用一部分&lt;string.h&gt;定义的函数</p>
<h2 id="SDS-nbsp-API"><a href="#SDS-nbsp-API" class="headerlink" title="SDS&nbsp;API"></a>SDS&nbsp;API</h2><p>常用API</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>sdsnew</td>
<td>创建一个包含给定 C 字符串的SDS 。</td>
<td>O(N) ， N 为给定 C 字符串的长度。</td>
</tr>
<tr>
<td>sdsempty</td>
<td>创建一个不包含任何内容的空SDS 。</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsfree</td>
<td>释放给定的 SDS 。</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdslen</td>
<td>返回 SDS 的已使用空间字节数。</td>
<td>这个值可以通过读取 SDS 的 len 属性来直接获得，复杂度为 O(1).</td>
</tr>
<tr>
<td>sdsavail</td>
<td>返回 SDS 的未使用空间字节数。</td>
<td>这个值可以通过读取 SDS 的 free 属性来直接获得， 复杂度为 O(1)。</td>
</tr>
<tr>
<td>sdsdup</td>
<td>创建一个给定 SDS 的副本（copy）。</td>
<td>O(N) ， N 为给定 SDS 的长度。</td>
</tr>
<tr>
<td>sdsclear</td>
<td>清空 SDS 保存的字符串内容。</td>
<td>因为惰性空间释放策略，复杂度为 O(1)。</td>
</tr>
<tr>
<td>sdscat</td>
<td>将给定 C 字符串拼接到 SDS 字符串的末尾。</td>
<td>O(N) ， N 为被拼接 C 字符串的长度。</td>
</tr>
<tr>
<td>sdscatsds</td>
<td>将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。</td>
<td>O(N) ， N 为被拼接 SDS 字符串的长度。</td>
</tr>
<tr>
<td>sdscpy</td>
<td>将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。</td>
<td>O(N) ， N 为被复制 C 字符串的长度。</td>
</tr>
<tr>
<td>sdsgrowzero</td>
<td>用空字符将 SDS 扩展至给定长度。</td>
<td>O(N) ， N 为扩展新增的字节数。</td>
</tr>
<tr>
<td>sdsrange</td>
<td>保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。</td>
<td>O(N) ， N 为被保留数据的字节数。</td>
</tr>
<tr>
<td>sdstrim</td>
<td>接受一个SDS和一个C字符串作为参数， 从 SDS 左右两端分别移除所有在C字符串中出现过的字符。</td>
<td>O(M*N)，M为 SDS的长度，N为给定C字符串的长度。</td>
</tr>
<tr>
<td>sdscmp</td>
<td>对比两个SDS字符串是否相同。</td>
<td>O(N)，N为两个SDS中较短的那个 SDS 的长度。</td>
</tr>
</tbody></table>
<br>

<hr>
<p>API原码注解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 根据给定的初始化字符串 init 和字符串长度 initlen</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 创建一个新的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  init ：初始化字符串指针</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  initlen ：初始化字符串的长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：创建成功返回 sdshdr 相对应的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *        创建失败返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string with the content specified by the 'init' pointer</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * and 'initlen'.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * If NULL is used for 'init' the string is initialized with zero bytes.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * The string is always null-termined (all the sds strings are, always) so</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * even if you create an sds string with:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * mystring = sdsnewlen("abc",3");</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * You can print the string with printf() as there is an implicit \0 at the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * end of the string. However the string is binary safe and can contain</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * \0 characters in the middle, as the length is stored in the sds header. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (init) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 内存分配失败，返回</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 设置初始化长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;len = initlen;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 以 \0 结尾</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 创建并返回一个只保存了空字符串 "" 的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：创建成功返回 sdshdr 相对应的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *        创建失败返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create an empty (zero length) sds string. Even in this case the string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * always has an implicit null term. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>,<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 根据给定字符串 init ，创建一个包含同样字符串的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  init ：如果输入为 NULL ，那么创建一个空白 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *         否则，新创建的 sds 中包含和 init 内容相同字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：创建成功返回 sdshdr 相对应的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *        创建失败返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string starting from a null termined C string. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复制给定 sds 的副本</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：创建成功返回输入 sds 的副本</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *        创建失败返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Duplicate an sds string. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 释放给定的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free an sds string. No operation is performed if 's' is NULL. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">    zfree(s-<span class="keyword">sizeof</span>(struct sdshdr));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用函数，可能已废弃</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the sds string length to the length as obtained with strlen(), so</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * considering as content only up to the first null term character.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * This function is useful when the sds string is hacked manually in some</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * way, like in the following example:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * s = sdsnew("foobar");</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * s[2] = '\0';</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * sdsupdatelen(s);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * printf("%d\n", sdslen(s));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * The output will be "2", but if we comment out the call to sdsupdatelen()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * the output will be "6" as the string was modified but the logical length</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * remains 6 bytes. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">138</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">139</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">140</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> reallen = <span class="built_in">strlen</span>(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">141</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;<span class="built_in">free</span> += (sh-&gt;len-reallen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">142</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;len = reallen;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">143</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">144</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">145</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">146</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 在不释放 SDS 的字符串空间的情况下，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">147</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 重置 SDS 所保存的字符串为空字符串。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">148</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">149</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">150</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">151</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">152</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Modify an sds string on-place to make it empty (zero length).</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">153</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * However all the existing buffer is not discarded but set as free space</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">154</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * so that next append operations will not require allocations up to the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">155</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * number of bytes previously available. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">156</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">157</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">158</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 取出 sdshdr</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">159</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">160</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">161</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 重新计算属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">162</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;<span class="built_in">free</span> += sh-&gt;len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">163</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;len = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">164</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">165</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 将结束符放到最前面（相当于惰性地删除 buf 中的内容）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">166</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;buf[<span class="number">0</span>] = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">167</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">168</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">169</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Enlarge the free space at the end of the sds string so that the caller</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">170</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * is sure that after calling this function can overwrite up to addlen</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">171</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * bytes after the end of the string, plus one more byte for nul term.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">172</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">173</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Note: this does not change the *length* of the sds string as returned</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">174</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * by sdslen(), but only the free buffer space we have. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">175</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">176</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">177</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">178</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">179</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">180</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">181</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：扩展成功返回扩展后的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">182</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *        扩展失败返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">183</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">184</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">185</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">186</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">187</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">188</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">189</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">190</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">191</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">192</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">193</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">194</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> len, newlen;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">195</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">196</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">197</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">198</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">199</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">200</span></pre></td><td class="code"><pre><span class="line">    len = sdslen(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">201</span></pre></td><td class="code"><pre><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">202</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">203</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// s 最少需要的长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">204</span></pre></td><td class="code"><pre><span class="line">    newlen = (len+addlen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">205</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">206</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">207</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">208</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">209</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">210</span></pre></td><td class="code"><pre><span class="line">        newlen *= <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">211</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">212</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">213</span></pre></td><td class="code"><pre><span class="line">        newlen += SDS_MAX_PREALLOC;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">214</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">215</span></pre></td><td class="code"><pre><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">216</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">217</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">218</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">219</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">220</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">221</span></pre></td><td class="code"><pre><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">222</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">223</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">224</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">225</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">226</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">227</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">228</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 回收 sds 中的空闲空间，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">229</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 回收不会对 sds 中保存的字符串内容做任何修改。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">230</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">231</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">232</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：内存调整后的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">233</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">234</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">235</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">236</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">237</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reallocate the sds string so that it has no free space at the end. The</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">238</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * contained string remains not altered, but next concatenation operations</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">239</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * will require a reallocation.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">240</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">241</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">242</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">243</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">244</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">245</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">246</span></pre></td><td class="code"><pre><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">247</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">248</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 进行内存重分配，让 buf 的长度仅仅足够保存字符串内容</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">249</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">250</span></pre></td><td class="code"><pre><span class="line">    sh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+sh-&gt;len+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">251</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">252</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 空余空间为 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">253</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">254</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">255</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sh-&gt;buf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">256</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">257</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">258</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">259</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回给定 sds 分配的内存字节数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">260</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">261</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">262</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">263</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">264</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the total size of the allocation of the specifed sds string,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">265</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * including:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">266</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 1) The sds header before the pointer.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">267</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 2) The string.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">268</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 3) The free buffer at the end if any.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">269</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 4) The implicit null term.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">270</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">271</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> sdsAllocSize(sds s) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">272</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">273</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">274</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(*sh)+sh-&gt;len+sh-&gt;<span class="built_in">free</span>+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">275</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">276</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">277</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Increment the sds length and decrements the left free space at the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">278</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * end of the string according to 'incr'. Also set the null term</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">279</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * in the new end of the string.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">280</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">281</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 根据 incr 参数，增加 sds 的长度，缩减空余空间，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">282</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 并将 \0 放到新字符串的尾端</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">283</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">284</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * This function is used in order to fix the string length after the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">285</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * user calls sdsMakeRoomFor(), writes something after the end of</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">286</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * the current string, and finally needs to set the new length.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">287</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">288</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 这个函数是在调用 sdsMakeRoomFor() 对字符串进行扩展，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">289</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 然后用户在字符串尾部写入了某些内容之后，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">290</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 用来正确更新 free 和 len 属性的。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">291</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">292</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Note: it is possible to use a negative increment in order to</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">293</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * right-trim the string.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">294</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">295</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 如果 incr 参数为负数，那么对字符串进行右截断操作。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">296</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">297</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Usage example:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">298</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">299</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">300</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * following schema, to cat bytes coming from the kernel to the end of an</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">301</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * sds string without copying into an intermediate buffer:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">302</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">303</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 以下是 sdsIncrLen 的用例：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">304</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">305</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * oldlen = sdslen(s);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">306</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * s = sdsMakeRoomFor(s, BUFFER_SIZE);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">307</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * nread = read(fd, s+oldlen, BUFFER_SIZE);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">308</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * ... check for nread &lt;= 0 and handle it ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">309</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * sdsIncrLen(s, nread);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">310</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">311</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">312</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">313</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">314</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">int</span> incr)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">315</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">316</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">317</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 确保 sds 空间足够</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">318</span></pre></td><td class="code"><pre><span class="line">    assert(sh-&gt;<span class="built_in">free</span> &gt;= incr);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">319</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">320</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 更新属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">321</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;len += incr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">322</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;<span class="built_in">free</span> -= incr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">323</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">324</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 这个 assert 其实可以忽略</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">325</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 因为前一个 assert 已经确保 sh-&gt;free - incr &gt;= 0 了</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">326</span></pre></td><td class="code"><pre><span class="line">    assert(sh-&gt;<span class="built_in">free</span> &gt;= <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">327</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">328</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 放置新的结尾符号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">329</span></pre></td><td class="code"><pre><span class="line">    s[sh-&gt;len] = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">330</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">331</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">332</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Grow the sds to have the specified length. Bytes that were not part of</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">333</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * the original length of the sds will be set to zero.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">334</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">335</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * if the specified length is smaller than the current length, no operation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">336</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * is performed. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">337</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">338</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将 sds 扩充至指定长度，未使用的空间以 0 字节填充。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">339</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">340</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">341</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：扩充成功返回新 sds ，失败返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">342</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">343</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">344</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">345</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">346</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">347</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">348</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> totlen, curlen = sh-&gt;len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">349</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">350</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果 len 比字符串的现有长度小，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">351</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 那么直接返回，不做动作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">352</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">353</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">354</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 扩展 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">355</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">356</span></pre></td><td class="code"><pre><span class="line">    s = sdsMakeRoomFor(s,len-curlen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">357</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果内存不足，直接返回</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">358</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">359</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">360</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Make sure added region doesn't contain garbage */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">361</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 将新分配的空间用 0 填充，防止出现垃圾内容</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">362</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">363</span></pre></td><td class="code"><pre><span class="line">    sh = (<span class="keyword">void</span>*)(s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">364</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">365</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">366</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 更新属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">367</span></pre></td><td class="code"><pre><span class="line">    totlen = sh-&gt;len+sh-&gt;<span class="built_in">free</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">368</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;len = len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">369</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-sh-&gt;len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">370</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">371</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回新的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">372</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">373</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">374</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">375</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">376</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将长度为 len 的字符串 t 追加到 sds 的字符串末尾</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">377</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">378</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">379</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：追加成功返回新 sds ，失败返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">380</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">381</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">382</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">383</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">384</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">385</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * end of the specified sds string 's'.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">386</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">387</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">388</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">389</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">390</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">391</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">392</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">393</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 原有字符串长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">394</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">395</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">396</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 扩展 sds 空间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">397</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">398</span></pre></td><td class="code"><pre><span class="line">    s = sdsMakeRoomFor(s,len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">399</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">400</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 内存不足？直接返回</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">401</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">402</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">403</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 复制 t 中的内容到字符串后部</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">404</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">405</span></pre></td><td class="code"><pre><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">406</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">407</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">408</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 更新属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">409</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;len = curlen+len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">410</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">411</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">412</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 添加新结尾符号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">413</span></pre></td><td class="code"><pre><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">414</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">415</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回新 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">416</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">417</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">418</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">419</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">420</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将给定字符串 t 追加到 sds 的末尾</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">421</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">422</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">423</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：追加成功返回新 sds ，失败返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">424</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">425</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">426</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">427</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">428</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append the specified null termianted C string to the sds string 's'.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">429</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">430</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">431</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">432</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">433</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">434</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">435</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">436</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">437</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将另一个 sds 追加到一个 sds 的末尾</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">438</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">439</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">440</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：追加成功返回新 sds ，失败返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">441</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">442</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">443</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">444</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">445</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append the specified sds 't' to the existing sds 's'.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">446</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">447</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * After the call, the modified sds string is no longer valid and all the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">448</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">449</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">450</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">451</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">452</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">453</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">454</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将字符串 t 的前 len 个字符复制到 sds s 当中，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">455</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 并在字符串的最后添加终结符。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">456</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">457</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 如果 sds 的长度少于 len 个字符，那么扩展 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">458</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">459</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">460</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">461</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">462</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">463</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：复制成功返回新的 sds ，否则返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">464</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">465</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Destructively modify the sds string 's' to hold the specified binary</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">466</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * safe string pointed by 't' of length 'len' bytes. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">467</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">468</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">469</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">470</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">471</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// sds 现有 buf 的长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">472</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">473</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">474</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果 s 的 buf 长度不满足 len ，那么扩展它</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">475</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (totlen &lt; len) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">476</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">477</span></pre></td><td class="code"><pre><span class="line">        s = sdsMakeRoomFor(s,len-sh-&gt;len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">478</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">479</span></pre></td><td class="code"><pre><span class="line">        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">480</span></pre></td><td class="code"><pre><span class="line">        totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">481</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">482</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">483</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 复制内容</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">484</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">485</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">memcpy</span>(s, t, len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">486</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">487</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 添加终结符号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">488</span></pre></td><td class="code"><pre><span class="line">    s[len] = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">489</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">490</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 更新属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">491</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;len = len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">492</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">493</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">494</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回新的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">495</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">496</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">497</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">498</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">499</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将字符串复制到 sds 当中，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">500</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 覆盖原有的字符。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">501</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">502</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 如果 sds 的长度少于字符串的长度，那么扩展 sds 。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">503</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">504</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">505</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">506</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">507</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">508</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds ：复制成功返回新的 sds ，否则返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">509</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">510</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Like sdscpylen() but 't' must be a null-termined string so that the length</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">511</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * of the string is obtained with strlen(). */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">512</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">513</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">514</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">515</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">516</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Helper for sdscatlonglong() doing the actual number -&gt; string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">517</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * conversion. 's' must point to a string with room for at least</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">518</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * SDS_LLSTR_SIZE bytes.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">519</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">520</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * The function returns the lenght of the null-terminated string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">521</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * representation stored at 's'. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">522</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_LLSTR_SIZE 21</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">523</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsll2str</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">524</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> *p, aux;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">525</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">526</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">527</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">528</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Generate the string representation, this method produces</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">529</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * an reversed string. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">530</span></pre></td><td class="code"><pre><span class="line">    v = (value &lt; <span class="number">0</span>) ? -value : value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">531</span></pre></td><td class="code"><pre><span class="line">    p = s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">532</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">533</span></pre></td><td class="code"><pre><span class="line">        *p++ = <span class="string">'0'</span>+(v%<span class="number">10</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">534</span></pre></td><td class="code"><pre><span class="line">        v /= <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">535</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span>(v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">536</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) *p++ = <span class="string">'-'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">537</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">538</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Compute length and add null term. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">539</span></pre></td><td class="code"><pre><span class="line">    l = p-s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">540</span></pre></td><td class="code"><pre><span class="line">    *p = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">541</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">542</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Reverse the string. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">543</span></pre></td><td class="code"><pre><span class="line">    p--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">544</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(s &lt; p) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">545</span></pre></td><td class="code"><pre><span class="line">        aux = *s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">546</span></pre></td><td class="code"><pre><span class="line">        *s = *p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">547</span></pre></td><td class="code"><pre><span class="line">        *p = aux;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">548</span></pre></td><td class="code"><pre><span class="line">        s++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">549</span></pre></td><td class="code"><pre><span class="line">        p--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">550</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">551</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">552</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">553</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">554</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Identical sdsll2str(), but for unsigned long long type. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">555</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsull2str</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">556</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> *p, aux;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">557</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">558</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">559</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Generate the string representation, this method produces</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">560</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * an reversed string. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">561</span></pre></td><td class="code"><pre><span class="line">    p = s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">562</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">563</span></pre></td><td class="code"><pre><span class="line">        *p++ = <span class="string">'0'</span>+(v%<span class="number">10</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">564</span></pre></td><td class="code"><pre><span class="line">        v /= <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">565</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span>(v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">566</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">567</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Compute length and add null term. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">568</span></pre></td><td class="code"><pre><span class="line">    l = p-s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">569</span></pre></td><td class="code"><pre><span class="line">    *p = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">570</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">571</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Reverse the string. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">572</span></pre></td><td class="code"><pre><span class="line">    p--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">573</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(s &lt; p) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">574</span></pre></td><td class="code"><pre><span class="line">        aux = *s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">575</span></pre></td><td class="code"><pre><span class="line">        *s = *p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">576</span></pre></td><td class="code"><pre><span class="line">        *p = aux;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">577</span></pre></td><td class="code"><pre><span class="line">        s++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">578</span></pre></td><td class="code"><pre><span class="line">        p--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">579</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">580</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">581</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">582</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">583</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create an sds string from a long long value. It is much faster than:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">584</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">585</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * sdscatprintf(sdsempty(),"%lld\n", value);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">586</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">587</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据输入的 long long 值 value ，创建一个 SDS</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">588</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">589</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">590</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> len = sdsll2str(buf,value);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">591</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">592</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sdsnewlen(buf,len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">593</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">594</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">595</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">596</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 打印函数，被 sdscatprintf 所调用</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">597</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">598</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(N^2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">599</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">600</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Like sdscatpritf() but gets va_list instead of being variadic. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">601</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">602</span></pre></td><td class="code"><pre><span class="line">    va_list cpy;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">603</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> staticbuf[<span class="number">1024</span>], *buf = staticbuf, *t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">604</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> buflen = <span class="built_in">strlen</span>(fmt)*<span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">605</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">606</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* We try to start using a static buffer for speed.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">607</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * If not possible we revert to heap allocation. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">608</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (buflen &gt; <span class="keyword">sizeof</span>(staticbuf)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">609</span></pre></td><td class="code"><pre><span class="line">        buf = zmalloc(buflen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">610</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">611</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">612</span></pre></td><td class="code"><pre><span class="line">        buflen = <span class="keyword">sizeof</span>(staticbuf);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">613</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">614</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">615</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Try with buffers two times bigger every time we fail to</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">616</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * fit the string in the current buffer size. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">617</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">618</span></pre></td><td class="code"><pre><span class="line">        buf[buflen<span class="number">-2</span>] = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">619</span></pre></td><td class="code"><pre><span class="line">        va_copy(cpy,ap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">620</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">621</span></pre></td><td class="code"><pre><span class="line">        vsnprintf(buf, buflen, fmt, cpy);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">622</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (buf[buflen<span class="number">-2</span>] != <span class="string">'\0'</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">623</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (buf != staticbuf) zfree(buf);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">624</span></pre></td><td class="code"><pre><span class="line">            buflen *= <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">625</span></pre></td><td class="code"><pre><span class="line">            buf = zmalloc(buflen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">626</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">627</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">628</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">629</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">630</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">631</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">632</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Finally concat the obtained string to the SDS string and return it. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">633</span></pre></td><td class="code"><pre><span class="line">    t = sdscat(s, buf);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">634</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (buf != staticbuf) zfree(buf);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">635</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">636</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">637</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">638</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">639</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 打印任意数量个字符串，并将这些字符串追加到给定 sds 的末尾</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">640</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">641</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(N^2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">642</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">643</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append to the sds string 's' a string obtained using printf-alike format</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">644</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * specifier.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">645</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">646</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * After the call, the modified sds string is no longer valid and all the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">647</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">648</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">649</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Example:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">650</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">651</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * s = sdsempty("Sum is: ");</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">652</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * s = sdscatprintf(s,"%d+%d = %d",a,b,a+b).</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">653</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">654</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Often you need to create a string from scratch with the printf-alike</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">655</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * format. When this is the need, just use sdsempty() as the target string:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">656</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">657</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * s = sdscatprintf(sdsempty(), "... your format ...", args);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">658</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">659</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">660</span></pre></td><td class="code"><pre><span class="line">    va_list ap;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">661</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> *t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">662</span></pre></td><td class="code"><pre><span class="line">    va_start(ap, fmt);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">663</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N^2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">664</span></pre></td><td class="code"><pre><span class="line">    t = sdscatvprintf(s,fmt,ap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">665</span></pre></td><td class="code"><pre><span class="line">    va_end(ap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">666</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">667</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">668</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">669</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is similar to sdscatprintf, but much faster as it does</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">670</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * not rely on sprintf() family functions implemented by the libc that</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">671</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * are often very slow. Moreover directly handling the sds string as</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">672</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * new data is concatenated provides a performance improvement.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">673</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">674</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * However this function only handles an incompatible subset of printf-alike</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">675</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * format specifiers:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">676</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">677</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * %s - C String</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">678</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * %S - SDS string</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">679</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * %i - signed int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">680</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * %I - 64 bit signed integer (long long, int64_t)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">681</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * %u - unsigned int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">682</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * %U - 64 bit unsigned integer (unsigned long long, uint64_t)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">683</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * %% - Verbatim "%" character.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">684</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">685</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">686</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">687</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> initlen = sdslen(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">688</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *f = fmt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">689</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">690</span></pre></td><td class="code"><pre><span class="line">    va_list ap;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">691</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">692</span></pre></td><td class="code"><pre><span class="line">    va_start(ap,fmt);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">693</span></pre></td><td class="code"><pre><span class="line">    f = fmt;    <span class="comment">/* Next format specifier byte to process. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">694</span></pre></td><td class="code"><pre><span class="line">    i = initlen; <span class="comment">/* Position of the next byte to write to dest str. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">695</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(*f) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">696</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">char</span> next, *str;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">697</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">size_t</span> l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">698</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">699</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> unum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">700</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">701</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* Make sure there is always space for at least 1 char. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">702</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sh-&gt;<span class="built_in">free</span> == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">703</span></pre></td><td class="code"><pre><span class="line">            s = sdsMakeRoomFor(s,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">704</span></pre></td><td class="code"><pre><span class="line">            sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">705</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">706</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">707</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">switch</span>(*f) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">708</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="string">'%'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">709</span></pre></td><td class="code"><pre><span class="line">            next = *(f+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">710</span></pre></td><td class="code"><pre><span class="line">            f++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">711</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">switch</span>(next) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">712</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">713</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">714</span></pre></td><td class="code"><pre><span class="line">                str = va_arg(ap,<span class="keyword">char</span>*);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">715</span></pre></td><td class="code"><pre><span class="line">                l = (next == <span class="string">'s'</span>) ? <span class="built_in">strlen</span>(str) : sdslen(str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">716</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (sh-&gt;<span class="built_in">free</span> &lt; l) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">717</span></pre></td><td class="code"><pre><span class="line">                    s = sdsMakeRoomFor(s,l);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">718</span></pre></td><td class="code"><pre><span class="line">                    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">719</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">720</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">memcpy</span>(s+i,str,l);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">721</span></pre></td><td class="code"><pre><span class="line">                sh-&gt;len += l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">722</span></pre></td><td class="code"><pre><span class="line">                sh-&gt;<span class="built_in">free</span> -= l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">723</span></pre></td><td class="code"><pre><span class="line">                i += l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">724</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">725</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'i'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">726</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">727</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (next == <span class="string">'i'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">728</span></pre></td><td class="code"><pre><span class="line">                    num = va_arg(ap,<span class="keyword">int</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">729</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">730</span></pre></td><td class="code"><pre><span class="line">                    num = va_arg(ap,<span class="keyword">long</span> <span class="keyword">long</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">731</span></pre></td><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">732</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">733</span></pre></td><td class="code"><pre><span class="line">                    l = sdsll2str(buf,num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">734</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (sh-&gt;<span class="built_in">free</span> &lt; l) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">735</span></pre></td><td class="code"><pre><span class="line">                        s = sdsMakeRoomFor(s,l);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">736</span></pre></td><td class="code"><pre><span class="line">                        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">737</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">738</span></pre></td><td class="code"><pre><span class="line">                    <span class="built_in">memcpy</span>(s+i,buf,l);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">739</span></pre></td><td class="code"><pre><span class="line">                    sh-&gt;len += l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">740</span></pre></td><td class="code"><pre><span class="line">                    sh-&gt;<span class="built_in">free</span> -= l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">741</span></pre></td><td class="code"><pre><span class="line">                    i += l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">742</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">743</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">744</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'u'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">745</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'U'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">746</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (next == <span class="string">'u'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">747</span></pre></td><td class="code"><pre><span class="line">                    unum = va_arg(ap,<span class="keyword">unsigned</span> <span class="keyword">int</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">748</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">749</span></pre></td><td class="code"><pre><span class="line">                    unum = va_arg(ap,<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">750</span></pre></td><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">751</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">752</span></pre></td><td class="code"><pre><span class="line">                    l = sdsull2str(buf,unum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">753</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (sh-&gt;<span class="built_in">free</span> &lt; l) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">754</span></pre></td><td class="code"><pre><span class="line">                        s = sdsMakeRoomFor(s,l);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">755</span></pre></td><td class="code"><pre><span class="line">                        sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">756</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">757</span></pre></td><td class="code"><pre><span class="line">                    <span class="built_in">memcpy</span>(s+i,buf,l);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">758</span></pre></td><td class="code"><pre><span class="line">                    sh-&gt;len += l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">759</span></pre></td><td class="code"><pre><span class="line">                    sh-&gt;<span class="built_in">free</span> -= l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">760</span></pre></td><td class="code"><pre><span class="line">                    i += l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">761</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">762</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">763</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">default</span>: <span class="comment">/* Handle %% and generally %&lt;unknown&gt;. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">764</span></pre></td><td class="code"><pre><span class="line">                s[i++] = next;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">765</span></pre></td><td class="code"><pre><span class="line">                sh-&gt;len += <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">766</span></pre></td><td class="code"><pre><span class="line">                sh-&gt;<span class="built_in">free</span> -= <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">767</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">768</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">769</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">770</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">771</span></pre></td><td class="code"><pre><span class="line">            s[i++] = *f;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">772</span></pre></td><td class="code"><pre><span class="line">            sh-&gt;len += <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">773</span></pre></td><td class="code"><pre><span class="line">            sh-&gt;<span class="built_in">free</span> -= <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">774</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">775</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">776</span></pre></td><td class="code"><pre><span class="line">        f++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">777</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">778</span></pre></td><td class="code"><pre><span class="line">    va_end(ap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">779</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">780</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Add null-term */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">781</span></pre></td><td class="code"><pre><span class="line">    s[i] = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">782</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">783</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">784</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">785</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">786</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 对 sds 左右两端进行修剪，清除其中 cset 指定的所有字符</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">787</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">788</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 比如 sdsstrim(xxyyabcyyxy, "xy") 将返回 "abc"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">789</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">790</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂性：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">791</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(M*N)，M 为 SDS 长度， N 为 cset 长度。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">792</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">793</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove the part of the string from left and from right composed just of</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">794</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * contiguous characters found in 'cset', that is a null terminted C string.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">795</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">796</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * After the call, the modified sds string is no longer valid and all the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">797</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">798</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">799</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Example:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">800</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">801</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * s = sdsnew("AA...AA.a.aa.aHelloWorld     :::");</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">802</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * s = sdstrim(s,"A. :");</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">803</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * printf("%s\n", s);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">804</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">805</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Output will be just "Hello World".</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">806</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">807</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">808</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">809</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">810</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">811</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">812</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 设置和记录指针</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">813</span></pre></td><td class="code"><pre><span class="line">    sp = start = s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">814</span></pre></td><td class="code"><pre><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">815</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">816</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 修剪, T = O(N^2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">817</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">818</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">819</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">820</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 计算 trim 完毕之后剩余的字符串长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">821</span></pre></td><td class="code"><pre><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">822</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">823</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果有需要，前移字符串内容</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">824</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">825</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">826</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">827</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 添加终结符</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">828</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;buf[len] = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">829</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">830</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 更新属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">831</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">832</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;len = len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">833</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">834</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 返回修剪后的 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">835</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">836</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">837</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">838</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">839</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 按索引对截取 sds 字符串的其中一段</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">840</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * start 和 end 都是闭区间（包含在内）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">841</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">842</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 索引从 0 开始，最大为 sdslen(s) - 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">843</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 索引可以是负数， sdslen(s) - 1 == -1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">844</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">845</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 复杂度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">846</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">847</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">848</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Turn the string into a smaller (or equal) string containing only the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">849</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * substring specified by the 'start' and 'end' indexes.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">850</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">851</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * start and end can be negative, where -1 means the last character of the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">852</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * string, -2 the penultimate character, and so forth.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">853</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">854</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * The interval is inclusive, so the start and end characters will be part</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">855</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * of the resulting string.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">856</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">857</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * The string is modified in-place.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">858</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">859</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Example:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">860</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">861</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * s = sdsnew("Hello World");</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">862</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * sdsrange(s,1,-1); =&gt; "ello World"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">863</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">864</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">865</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">866</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> newlen, len = sdslen(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">867</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">868</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">869</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">870</span></pre></td><td class="code"><pre><span class="line">        start = len+start;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">871</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">872</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">873</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">874</span></pre></td><td class="code"><pre><span class="line">        end = len+end;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">875</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">876</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">877</span></pre></td><td class="code"><pre><span class="line">    newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">878</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (newlen != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">879</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (start &gt;= (<span class="keyword">signed</span>)len) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">880</span></pre></td><td class="code"><pre><span class="line">            newlen = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">881</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt;= (<span class="keyword">signed</span>)len) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">882</span></pre></td><td class="code"><pre><span class="line">            end = len<span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">883</span></pre></td><td class="code"><pre><span class="line">            newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">884</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">885</span></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">886</span></pre></td><td class="code"><pre><span class="line">        start = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">887</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">888</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">889</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果有需要，对字符串进行移动</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">890</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">891</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (start &amp;&amp; newlen) memmove(sh-&gt;buf, sh-&gt;buf+start, newlen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">892</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">893</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 添加终结符</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">894</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;buf[newlen] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">895</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">896</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 更新属性</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">897</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-newlen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">898</span></pre></td><td class="code"><pre><span class="line">    sh-&gt;len = newlen;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">899</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">900</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">901</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">902</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将 sds 字符串中的所有字符转换为小写</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">903</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">904</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">905</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">906</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Apply tolower() to every character of the sds string 's'. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">907</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">908</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">909</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">910</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">tolower</span>(s[j]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">911</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">912</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">913</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">914</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将 sds 字符串中的所有字符转换为大写</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">915</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">916</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">917</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">918</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Apply toupper() to every character of the sds string 's'. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">919</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">920</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">921</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">922</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">toupper</span>(s[j]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">923</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">924</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">925</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">926</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 对比两个 sds ， strcmp 的 sds 版本</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">927</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">928</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 返回值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">929</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  int ：相等返回 0 ，s1 较大返回正数， s2 较大返回负数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">930</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">931</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">932</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">933</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare two sds strings s1 and s2 with memcmp().</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">934</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">935</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Return value:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">936</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">937</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *     1 if s1 &gt; s2.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">938</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *    -1 if s1 &lt; s2.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">939</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *     0 if s1 and s2 are exactly the same binary string.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">940</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">941</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * If two strings share exactly the same prefix, but one of the two has</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">942</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * additional characters, the longer string is considered to be greater than</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">943</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * the smaller one. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">944</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">945</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> l1, l2, minlen;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">946</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> cmp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">947</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">948</span></pre></td><td class="code"><pre><span class="line">    l1 = sdslen(s1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">949</span></pre></td><td class="code"><pre><span class="line">    l2 = sdslen(s2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">950</span></pre></td><td class="code"><pre><span class="line">    minlen = (l1 &lt; l2) ? l1 : l2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">951</span></pre></td><td class="code"><pre><span class="line">    cmp = <span class="built_in">memcmp</span>(s1,s2,minlen);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">952</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">953</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> l1-l2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">954</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">955</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> cmp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">956</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">957</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">958</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Split 's' with separator in 'sep'. An array</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">959</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * of sds strings is returned. *count will be set</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">960</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * by reference to the number of tokens returned.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">961</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">962</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 使用分隔符 sep 对 s 进行分割，返回一个 sds 字符串的数组。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">963</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * *count 会被设置为返回数组元素的数量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">964</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">965</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * On out of memory, zero length string, zero length</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">966</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * separator, NULL is returned.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">967</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">968</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 如果出现内存不足、字符串长度为 0 或分隔符长度为 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">969</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 的情况，返回 NULL</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">970</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">971</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Note that 'sep' is able to split a string using</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">972</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * a multi-character separator. For example</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">973</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * sdssplit("foo_-_bar","_-_"); will return two</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">974</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * elements "foo" and "bar".</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">975</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">976</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 注意分隔符可以的是包含多个字符的字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">977</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">978</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * This version of the function is binary-safe but</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">979</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * requires length arguments. sdssplit() is just the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">980</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * same function but for zero-terminated strings.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">981</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">982</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 这个函数接受 len 参数，因此它是二进制安全的。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">983</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * （文档中提到的 sdssplit() 已废弃）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">984</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">985</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(N^2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">986</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">987</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">988</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> elements = <span class="number">0</span>, slots = <span class="number">5</span>, start = <span class="number">0</span>, j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">989</span></pre></td><td class="code"><pre><span class="line">    sds *tokens;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">990</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">991</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (seplen &lt; <span class="number">1</span> || len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">992</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">993</span></pre></td><td class="code"><pre><span class="line">    tokens = zmalloc(<span class="keyword">sizeof</span>(sds)*slots);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">994</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (tokens == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">995</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">996</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">997</span></pre></td><td class="code"><pre><span class="line">        *count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">998</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> tokens;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">999</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1000</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1001</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// T = O(N^2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1002</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (len-(seplen<span class="number">-1</span>)); j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1003</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* make sure there is room for the next element and the final one */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1004</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (slots &lt; elements+<span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1005</span></pre></td><td class="code"><pre><span class="line">            sds *newtokens;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1006</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1007</span></pre></td><td class="code"><pre><span class="line">            slots *= <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1008</span></pre></td><td class="code"><pre><span class="line">            newtokens = zrealloc(tokens,<span class="keyword">sizeof</span>(sds)*slots);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1009</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (newtokens == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1010</span></pre></td><td class="code"><pre><span class="line">            tokens = newtokens;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1011</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1012</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* search the separator */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1013</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1014</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((seplen == <span class="number">1</span> &amp;&amp; *(s+j) == sep[<span class="number">0</span>]) || (<span class="built_in">memcmp</span>(s+j,sep,seplen) == <span class="number">0</span>)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1015</span></pre></td><td class="code"><pre><span class="line">            tokens[elements] = sdsnewlen(s+start,j-start);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1016</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1017</span></pre></td><td class="code"><pre><span class="line">            elements++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1018</span></pre></td><td class="code"><pre><span class="line">            start = j+seplen;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1019</span></pre></td><td class="code"><pre><span class="line">            j = j+seplen<span class="number">-1</span>; <span class="comment">/* skip the separator */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1020</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1021</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1022</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Add the final element. We are sure there is room in the tokens array. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1023</span></pre></td><td class="code"><pre><span class="line">    tokens[elements] = sdsnewlen(s+start,len-start);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1024</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1025</span></pre></td><td class="code"><pre><span class="line">    elements++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1026</span></pre></td><td class="code"><pre><span class="line">    *count = elements;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1027</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> tokens;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1028</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1029</span></pre></td><td class="code"><pre><span class="line">cleanup:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1030</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1031</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1032</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) sdsfree(tokens[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1033</span></pre></td><td class="code"><pre><span class="line">        zfree(tokens);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1034</span></pre></td><td class="code"><pre><span class="line">        *count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1035</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1036</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1037</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1038</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1039</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1040</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 释放 tokens 数组中 count 个 sds</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1041</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1042</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(N^2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1043</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1044</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1045</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1046</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!tokens) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1047</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(count--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1048</span></pre></td><td class="code"><pre><span class="line">        sdsfree(tokens[count]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1049</span></pre></td><td class="code"><pre><span class="line">    zfree(tokens);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1050</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1051</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1052</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1053</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将长度为 len 的字符串 p 以带引号（quoted）的格式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1054</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 追加到给定 sds 的末尾</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1055</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1056</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1057</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1058</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append to the sds string "s" an escaped string representation where</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1059</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * all the non-printable characters (tested with isprint()) are turned into</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1060</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * escapes in the form "\n\r\a...." or "\x&lt;hex-number&gt;".</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1061</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1062</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * After the call, the modified sds string is no longer valid and all the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1063</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1064</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1065</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1066</span></pre></td><td class="code"><pre><span class="line">    s = sdscatlen(s,<span class="string">"\""</span>,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1067</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1068</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(len--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1069</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">switch</span>(*p) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1070</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="string">'\\'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1071</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="string">'"'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1072</span></pre></td><td class="code"><pre><span class="line">            s = sdscatprintf(s,<span class="string">"\\%c"</span>,*p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1073</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1074</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>: s = sdscatlen(s,<span class="string">"\\n"</span>,<span class="number">2</span>); <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1075</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>: s = sdscatlen(s,<span class="string">"\\r"</span>,<span class="number">2</span>); <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1076</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>: s = sdscatlen(s,<span class="string">"\\t"</span>,<span class="number">2</span>); <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1077</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="string">'\a'</span>: s = sdscatlen(s,<span class="string">"\\a"</span>,<span class="number">2</span>); <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1078</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="string">'\b'</span>: s = sdscatlen(s,<span class="string">"\\b"</span>,<span class="number">2</span>); <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1079</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1080</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (<span class="built_in">isprint</span>(*p))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1081</span></pre></td><td class="code"><pre><span class="line">                s = sdscatprintf(s,<span class="string">"%c"</span>,*p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1082</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1083</span></pre></td><td class="code"><pre><span class="line">                s = sdscatprintf(s,<span class="string">"\\x%02x"</span>,(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1084</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1085</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1086</span></pre></td><td class="code"><pre><span class="line">        p++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1087</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1088</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1089</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> sdscatlen(s,<span class="string">"\""</span>,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1090</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1091</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1092</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Helper function for sdssplitargs() that returns non zero if 'c'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1093</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * is a valid hex digit. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1094</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1095</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 如果 c 为十六进制符号的其中一个，返回正数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1096</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1097</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1098</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1099</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_hex_digit</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1100</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'f'</span>) ||</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1101</span></pre></td><td class="code"><pre><span class="line">           (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'F'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1102</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1103</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1104</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Helper function for sdssplitargs() that converts a hex digit into an</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1105</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * integer from 0 to 15 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1106</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1107</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将十六进制符号转换为 10 进制</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1108</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1109</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1110</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1111</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hex_digit_to_int</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1112</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">switch</span>(c) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1113</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span>: <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1114</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'1'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1115</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'2'</span>: <span class="keyword">return</span> <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1116</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'3'</span>: <span class="keyword">return</span> <span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1117</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'4'</span>: <span class="keyword">return</span> <span class="number">4</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1118</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'5'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1119</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'6'</span>: <span class="keyword">return</span> <span class="number">6</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1120</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'7'</span>: <span class="keyword">return</span> <span class="number">7</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1121</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'8'</span>: <span class="keyword">return</span> <span class="number">8</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1122</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'9'</span>: <span class="keyword">return</span> <span class="number">9</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1123</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1124</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'b'</span>: <span class="keyword">case</span> <span class="string">'B'</span>: <span class="keyword">return</span> <span class="number">11</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1125</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>: <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">12</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1126</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'d'</span>: <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">13</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1127</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'E'</span>: <span class="keyword">return</span> <span class="number">14</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1128</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="string">'f'</span>: <span class="keyword">case</span> <span class="string">'F'</span>: <span class="keyword">return</span> <span class="number">15</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1129</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1130</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1131</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1132</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1133</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Split a line into arguments, where every argument can be in the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1134</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * following programming-language REPL-alike form:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1135</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1136</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将一行文本分割成多个参数，每个参数可以有以下的类编程语言 REPL 格式：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1137</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1138</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * foo bar "newline are supported\n" and "\xff\x00otherstuff"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1139</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1140</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * The number of arguments is stored into *argc, and an array</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1141</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * of sds is returned.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1142</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1143</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 参数的个数会保存在 *argc 中，函数返回一个 sds 数组。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1144</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1145</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * The caller should free the resulting array of sds strings with</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1146</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * sdsfreesplitres().</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1147</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1148</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 调用者应该使用 sdsfreesplitres() 来释放函数返回的 sds 数组。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1149</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1150</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Note that sdscatrepr() is able to convert back a string into</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1151</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * a quoted string in the same format sdssplitargs() is able to parse.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1152</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1153</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * sdscatrepr() 可以将一个字符串转换为一个带引号（quoted）的字符串，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1154</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 这个带引号的字符串可以被 sdssplitargs() 分析。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1155</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1156</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * The function returns the allocated tokens on success, even when the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1157</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * input string is empty, or NULL if the input contains unbalanced</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1158</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * quotes or closed quotes followed by non space characters</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1159</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * as in: "foo"bar or "foo'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1160</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1161</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 即使输入出现空字符串， NULL ，或者输入带有未对应的括号，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1162</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 函数都会将已成功处理的字符串先返回。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1163</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1164</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 这个函数主要用于 config.c 中对配置文件进行分析。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1165</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 例子：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1166</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  sds *arr = sdssplitargs("timeout 10086\r\nport 123321\r\n");</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1167</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 会得出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1168</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  arr[0] = "timeout"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1169</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  arr[1] = "10086"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1170</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  arr[2] = "port"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1171</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *  arr[3] = "123321"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1172</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1173</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(N^2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1174</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1175</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds *<span class="title">sdssplitargs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *line, <span class="keyword">int</span> *argc)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1176</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = line;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1177</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> *current = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1178</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> **<span class="built_in">vector</span> = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1179</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1180</span></pre></td><td class="code"><pre><span class="line">    *argc = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1181</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1182</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1183</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* skip blanks */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1184</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 跳过空白</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1185</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1186</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span>(*p &amp;&amp; <span class="built_in">isspace</span>(*p)) p++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1187</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1188</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (*p) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1189</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* get a token */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1190</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> inq=<span class="number">0</span>;  <span class="comment">/* set to 1 if we are in "quotes" */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1191</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> insq=<span class="number">0</span>; <span class="comment">/* set to 1 if we are in 'single quotes' */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1192</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> done=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1193</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1194</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (current == <span class="literal">NULL</span>) current = sdsempty();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1195</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1196</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1197</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span>(!done) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1198</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (inq) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1199</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="string">'x'</span> &amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1200</span></pre></td><td class="code"><pre><span class="line">                                             is_hex_digit(*(p+<span class="number">2</span>)) &amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1201</span></pre></td><td class="code"><pre><span class="line">                                             is_hex_digit(*(p+<span class="number">3</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1202</span></pre></td><td class="code"><pre><span class="line">                    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1203</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">unsigned</span> <span class="keyword">char</span> byte;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1204</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1205</span></pre></td><td class="code"><pre><span class="line">                        byte = (hex_digit_to_int(*(p+<span class="number">2</span>))*<span class="number">16</span>)+</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1206</span></pre></td><td class="code"><pre><span class="line">                                hex_digit_to_int(*(p+<span class="number">3</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1207</span></pre></td><td class="code"><pre><span class="line">                        current = sdscatlen(current,(<span class="keyword">char</span>*)&amp;byte,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1208</span></pre></td><td class="code"><pre><span class="line">                        p += <span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1209</span></pre></td><td class="code"><pre><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1210</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">char</span> c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1211</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1212</span></pre></td><td class="code"><pre><span class="line">                        p++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1213</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">switch</span>(*p) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1214</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">case</span> <span class="string">'n'</span>: c = <span class="string">'\n'</span>; <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1215</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">case</span> <span class="string">'r'</span>: c = <span class="string">'\r'</span>; <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1216</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">case</span> <span class="string">'t'</span>: c = <span class="string">'\t'</span>; <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1217</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">case</span> <span class="string">'b'</span>: c = <span class="string">'\b'</span>; <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1218</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">case</span> <span class="string">'a'</span>: c = <span class="string">'\a'</span>; <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1219</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">default</span>: c = *p; <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1220</span></pre></td><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1221</span></pre></td><td class="code"><pre><span class="line">                        current = sdscatlen(current,&amp;c,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1222</span></pre></td><td class="code"><pre><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'"'</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1223</span></pre></td><td class="code"><pre><span class="line">                        <span class="comment">/* closing quote must be followed by a space or</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1224</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                         * nothing at all. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1225</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">if</span> (*(p+<span class="number">1</span>) &amp;&amp; !<span class="built_in">isspace</span>(*(p+<span class="number">1</span>))) <span class="keyword">goto</span> err;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1226</span></pre></td><td class="code"><pre><span class="line">                        done=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1227</span></pre></td><td class="code"><pre><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!*p) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1228</span></pre></td><td class="code"><pre><span class="line">                        <span class="comment">/* unterminated quotes */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1229</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">goto</span> err;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1230</span></pre></td><td class="code"><pre><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1231</span></pre></td><td class="code"><pre><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1232</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1233</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (insq) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1234</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (*p == <span class="string">'\\'</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="string">'\''</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1235</span></pre></td><td class="code"><pre><span class="line">                        p++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1236</span></pre></td><td class="code"><pre><span class="line">                        current = sdscatlen(current,<span class="string">"'"</span>,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1237</span></pre></td><td class="code"><pre><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">'\''</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1238</span></pre></td><td class="code"><pre><span class="line">                        <span class="comment">/* closing quote must be followed by a space or</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1239</span></pre></td><td class="code"><pre><span class="line"><span class="comment">                         * nothing at all. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1240</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">if</span> (*(p+<span class="number">1</span>) &amp;&amp; !<span class="built_in">isspace</span>(*(p+<span class="number">1</span>))) <span class="keyword">goto</span> err;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1241</span></pre></td><td class="code"><pre><span class="line">                        done=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1242</span></pre></td><td class="code"><pre><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!*p) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1243</span></pre></td><td class="code"><pre><span class="line">                        <span class="comment">/* unterminated quotes */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1244</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">goto</span> err;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1245</span></pre></td><td class="code"><pre><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1246</span></pre></td><td class="code"><pre><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1247</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1248</span></pre></td><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1249</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">switch</span>(*p) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1250</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">case</span> <span class="string">' '</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1251</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">case</span> <span class="string">'\n'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1252</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">case</span> <span class="string">'\r'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1253</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">case</span> <span class="string">'\t'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1254</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">case</span> <span class="string">'\0'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1255</span></pre></td><td class="code"><pre><span class="line">                        done=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1256</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1257</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">case</span> <span class="string">'"'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1258</span></pre></td><td class="code"><pre><span class="line">                        inq=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1259</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1260</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">case</span> <span class="string">'\''</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1261</span></pre></td><td class="code"><pre><span class="line">                        insq=<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1262</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1263</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1264</span></pre></td><td class="code"><pre><span class="line">                        current = sdscatlen(current,p,<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1265</span></pre></td><td class="code"><pre><span class="line">                        <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1266</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1267</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1268</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span> (*p) p++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1269</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1270</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* add the token to the vector */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1271</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// T = O(N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1272</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">vector</span> = zrealloc(<span class="built_in">vector</span>,((*argc)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1273</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">vector</span>[*argc] = current;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1274</span></pre></td><td class="code"><pre><span class="line">            (*argc)++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1275</span></pre></td><td class="code"><pre><span class="line">            current = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1276</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1277</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* Even on empty input string return something not NULL. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1278</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (<span class="built_in">vector</span> == <span class="literal">NULL</span>) <span class="built_in">vector</span> = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1279</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1280</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1281</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1282</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1283</span></pre></td><td class="code"><pre><span class="line">err:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1284</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>((*argc)--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1285</span></pre></td><td class="code"><pre><span class="line">        sdsfree(<span class="built_in">vector</span>[*argc]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1286</span></pre></td><td class="code"><pre><span class="line">    zfree(<span class="built_in">vector</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1287</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (current) sdsfree(current);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1288</span></pre></td><td class="code"><pre><span class="line">    *argc = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1289</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1290</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1291</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1292</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Modify the string substituting all the occurrences of the set of</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1293</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * characters specified in the 'from' string to the corresponding character</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1294</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * in the 'to' array.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1295</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1296</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 将字符串 s 中，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1297</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 所有在 from 中出现的字符，替换成 to 中的字符</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1298</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1299</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * For instance: sdsmapchars(mystring, "ho", "01", 2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1300</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * will have the effect of turning the string "hello" into "0ell1".</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1301</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1302</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 比如调用 sdsmapchars(mystring, "ho", "01", 2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1303</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 就会将 "hello" 转换为 "0ell1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1304</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1305</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * The function returns the sds string pointer, that is always the same</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1306</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * as the input pointer since no resize is needed. </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1307</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 因为无须对 sds 进行大小调整，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1308</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * 所以返回的 sds 输入的 sds 一样</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1309</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> *</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1310</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * T = O(N^2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1311</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1312</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsmapchars</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *from, <span class="keyword">const</span> <span class="keyword">char</span> *to, <span class="keyword">size_t</span> setlen)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1313</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> j, i, l = sdslen(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1314</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1315</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 遍历输入字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1316</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1317</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 遍历映射</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1318</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setlen; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1319</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 替换字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1320</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (s[j] == from[i]) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1321</span></pre></td><td class="code"><pre><span class="line">                s[j] = to[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1322</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1323</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1324</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1325</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1326</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1327</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1328</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1329</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Join an array of C strings using the specified separator (also a C string).</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1330</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Returns the result as an sds string. */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1331</span></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1332</span></pre></td><td class="code"><pre><span class="line">    sds join = sdsempty();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1333</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1334</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1335</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1336</span></pre></td><td class="code"><pre><span class="line">        join = sdscat(join, argv[j]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1337</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (j != argc<span class="number">-1</span>) join = sdscat(join,sep);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1338</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1339</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> join;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">1340</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
    </div>

    
    
    
        <div class="reward-container">
  <div>您的支持将鼓励我继续创作！</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="RocWong 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>RocWong
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="/https:/rocwong.top/2019/04/15/redis%E6%BA%90%E7%A0%81-sds/" title="redis源码-sds">https://rocwong.top/2019/04/15/redis源码-sds/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"><i class="fa fa-tag"></i> 源码</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/11/deepin%E5%BC%80%E6%9C%BA%E5%90%8E%E5%81%87%E6%AD%BB/" rel="prev" title="deepin开机后假死">
      <i class="fa fa-chevron-left"></i> deepin开机后假死
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/04/16/redis%E6%BA%90%E7%A0%81-adlist/" rel="next" title="redis源码-adlist">
      redis源码-adlist <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SDS-动态字符串定义"><span class="nav-number">1.</span> <span class="nav-text">SDS-动态字符串定义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SDS与C的字符串区别"><span class="nav-number">2.</span> <span class="nav-text">SDS与C的字符串区别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常数复杂度获取字符串长度"><span class="nav-number">2.1.</span> <span class="nav-text">常数复杂度获取字符串长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#杜绝缓冲区溢出"><span class="nav-number">2.2.</span> <span class="nav-text">杜绝缓冲区溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS空间分配策略"><span class="nav-number">2.2.1.</span> <span class="nav-text">SDS空间分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#减少修改字符串时带来的内存重分配次数"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">减少修改字符串时带来的内存重分配次数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#空间预分配"><span class="nav-number">2.2.1.1.1.</span> <span class="nav-text">空间预分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#惰性空间释放"><span class="nav-number">2.2.1.1.2.</span> <span class="nav-text">惰性空间释放</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制安全"><span class="nav-number">2.2.2.</span> <span class="nav-text">二进制安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#兼容部分C字符串函数"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">兼容部分C字符串函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDS-nbsp-API"><span class="nav-number">2.3.</span> <span class="nav-text">SDS API</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="RocWong"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">RocWong</p>
  <div class="site-description" itemprop="description">人法地、地法天、天法道、道法自然</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>


      <div>
            <!-- none-select-br -->

            <p></p>

            <!-- hitokoto -->

            <div class="hitokoto-title">
	            <i class="fa fa-paragraph"></i>
	            <b>一言</b>
            </div>

            <div id="hitokoto">:D 获取中...</div>
            <i id="hitofrom">:D 获取中...</i>

            <script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script>
            <script>
              fetch('https://v1.hitokoto.cn')
                .then(function (res){
                  return res.json();
                })
                .then(function (data) {
                  var hitokoto = document.getElementById('hitokoto');
                  hitokoto.innerText = '\xa0\xa0' + data.hitokoto;
                  var hitofrom = document.getElementById('hitofrom');
                  hitofrom.innerText = "——" + data.from + '\xa0'; 
                })
                .catch(function (err) {
                  console.error(err);
                })
            </script>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">湘ICP备18000496 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RocWong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">429k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:01</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=akQ7J933kSkT6bS8EGY4mz1S-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'akQ7J933kSkT6bS8EGY4mz1S-gzGzoHsz',
            'X-LC-Key': 'Nzpwf4hnsjlU9jOzMC0HmReR',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


        
      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script><script src="/js/algolia-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>



  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout: 3000,
        priority: true,
        ignores: [uri => uri.includes('#'),uri => uri == 'https://rocwong.top/2019/04/15/redis%E6%BA%90%E7%A0%81-sds/',]
      });
      });
  </script>


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'akQ7J933kSkT6bS8EGY4mz1S-gzGzoHsz',
    appKey: 'Nzpwf4hnsjlU9jOzMC0HmReR',
    placeholder: "在此处留言,请一并在右上方留下邮箱,这样当我回复您时，您能收到邮件通知",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

<script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json"},"display":{"superSample":2,"position":"right","width":150,"height":300,"hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body>
</html>
