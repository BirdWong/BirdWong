{"pages":[{"title":"404","text":"","path":"404/index.html","date":"04-09","excerpt":""},{"title":"archives","text":"","path":"archives/index.html","date":"04-09","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"04-09","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"04-09","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"04-09","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"04-09","excerpt":""}],"posts":[{"title":"redis源码-sds","text":"SDS-动态字符串定义SDS定义于sds.h/sds.c文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * 这个版本中， 不同的字符串长度使用的都是同一个结构体， * 这样会造成一定的内存浪费 * version 3.0 */ struct sdshdr &#123; // 字符串的长度 unsigned int len; // 记录buf中未使用字节的数量 unsigned int free; // 字节数组，用于保存字符串 char buf[];&#125;;/* * 提供五种header定义，满足各种字符串大小 * len：字符串的长度 * alloc：字符串最大容量 * flags：标记header的类型 * buf： 字节数组，用于保存字符串 * version 5.0 */typedef char *sds;/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */struct __attribute__ ((__packed__)) sdshdr5 &#123; unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr8 &#123; uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr16 &#123; uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32 &#123; uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr64 &#123; uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];&#125;; 例如： 目前：free=0、len=5、buf是一个char类型数组，我们向里面存入redis五个字符，则buf里面将会存入’r’,’e’,’d’,’i’,’s’,’\\0’,最后一个是空字符，这个并不会被len所记录，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作都是SDS函数自动完成的，所以这个空字符对于SDS的使用者是完全透明的，这个空字符对于但是却很重要，关系到我们重用C字符串函数库里面的函数 SDS与C的字符串区别常数复杂度获取字符串长度场景：C字符串长度为N，则需要N+1长度数组存储（最后一位存空字符），现在需要获取字符串长度需要的复杂度是多少？答案：O(n)， 过程是我们遍历整个字符串，对每个字符进行计数，直到遇到代表字符串结尾的空字符。 如果是SDS呢，那么我们的时间复杂度是O(1),因为我们的len属性中记录了SDS本身的长度。 杜绝缓冲区溢出除了获取字符串长度的复杂度搞之外，C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出例如：1char *strcat(char *dest, const char *src); 我们将src字符串中的内容配接到dest字符串的末尾的时候，因为C字符串不记录自身的长度，所以strcat假定用户在执行这个函数时已经为dest分配了足够多的内存，可以容纳src字符串中的所有内容，如果上述条件不成立，则会产生缓冲区溢出 例如：程序中有两个在内存中紧邻的两个字符串s1,s2分别是’redis’,’mongodb’ 如果这个时候执行strcat(s1,&quot; Cluster&quot;);将s1中的内容修改为’Redis Cluster’，忘记为s1分配足够的空间，那么将会导致s2内容被意外地修改 SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话API会自动将SDS的空间扩展至执行修改所需的大小，所以SDS不需要手动修改SDS的空间大小也不会出现缓冲区溢出问题。 SDS空间分配策略减少修改字符串时带来的内存重分配次数前面说过，C字符串并不记录自身的长度，对于包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组，所以每次增长或者缩短一个C字符串都需要一次内存重分配。如果不重新分配会造成两种情况 如果程序增长没有重新分配内存空间大小，会产生缓冲区溢出 如果缩短字符串操作没有重新分配空间，会产生内存泄漏 空间预分配 如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。 如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte 。 例如： sdscat(s, &quot; Cluster&quot;);,那么 sdscat 将执行一次内存重分配操作， 将 SDS 的长度修改为 13 字节， 并将 SDS 的未使用空间同样修改为 13 字节， 如果这个时候我们再执行sdscat(s, &quot; Tutorial&quot;); 这是因为我们已经有13字节足以保存9字节的” Tutorial”,在扩展 SDS 空间之前， SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配。 通过这种预分配策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。 惰性空间释放惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。例如： S=”XYXXYabcXYY”，我们执行sdstrim(s, &quot;XY&quot;);移除S字符串中的所有 ‘X’ 和 ‘Y’。 这个时候SDS并没有释放多出来的8个字节，而是将这8个字节空间保留在了SDS里面，如果之后对SDS进行增长操作的话，这些空间就能派上用场。 同时，SDS也提供了相应的API，让我们可以在有需要时真正的释放SDS里面的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。 二进制安全在C字符串中， 除了字符串末尾外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，所以不能用来保存二进制数据等一些特殊数据。但是SDS使用buf保存二进制数据，特殊格式等对其无影响，因为SDS使用len属性的值而不是空字符串来判断字符串是否结束。 兼容部分C字符串函数SDS的API是二进制安全的，但它一样遵循C字符串以空字符结尾的惯例，这些API总会将SDS保存的数据的末尾设置为空字符，并且会为buf数组分配空一格字节的空间容纳这个空字符，这是为了让那些文本数据的SDS可以重用一部分&lt;string.h&gt;定义的函数 SDS&nbsp;API常用API 函数 作用 时间复杂度 sdsnew 创建一个包含给定 C 字符串的SDS 。 O(N) ， N 为给定 C 字符串的长度。 sdsempty 创建一个不包含任何内容的空SDS 。 O(1) sdsfree 释放给定的 SDS 。 O(1) sdslen 返回 SDS 的已使用空间字节数。 这个值可以通过读取 SDS 的 len 属性来直接获得，复杂度为 O(1). sdsavail 返回 SDS 的未使用空间字节数。 这个值可以通过读取 SDS 的 free 属性来直接获得， 复杂度为 O(1)。 sdsdup 创建一个给定 SDS 的副本（copy）。 O(N) ， N 为给定 SDS 的长度。 sdsclear 清空 SDS 保存的字符串内容。 因为惰性空间释放策略，复杂度为 O(1)。 sdscat 将给定 C 字符串拼接到 SDS 字符串的末尾。 O(N) ， N 为被拼接 C 字符串的长度。 sdscatsds 将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。 O(N) ， N 为被拼接 SDS 字符串的长度。 sdscpy 将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。 O(N) ， N 为被复制 C 字符串的长度。 sdsgrowzero 用空字符将 SDS 扩展至给定长度。 O(N) ， N 为扩展新增的字节数。 sdsrange 保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。 O(N) ， N 为被保留数据的字节数。 sdstrim 接受一个SDS和一个C字符串作为参数， 从 SDS 左右两端分别移除所有在C字符串中出现过的字符。 O(M*N)，M为 SDS的长度，N为给定C字符串的长度。 sdscmp 对比两个SDS字符串是否相同。 O(N)，N为两个SDS中较短的那个 SDS 的长度。 API原码注解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313sds sdsnewlen(const void *init, size_t initlen) &#123; struct sdshdr *sh; // 根据是否有初始化内容，选择适当的内存分配方式 // T = O(N) if (init) &#123; // zmalloc 不初始化所分配的内存 sh = zmalloc(sizeof(struct sdshdr)+initlen+1); &#125; else &#123; // zcalloc 将分配的内存全部初始化为 0 sh = zcalloc(sizeof(struct sdshdr)+initlen+1); &#125; // 内存分配失败，返回 if (sh == NULL) return NULL; // 设置初始化长度 sh-&gt;len = initlen; // 新 sds 不预留任何空间 sh-&gt;free = 0; // 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中 // T = O(N) if (initlen &amp;&amp; init) memcpy(sh-&gt;buf, init, initlen); // 以 \\0 结尾 sh-&gt;buf[initlen] = '\\0'; // 返回 buf 部分，而不是整个 sdshdr return (char*)sh-&gt;buf;&#125;/* * 创建并返回一个只保存了空字符串 \"\" 的 sds * * 返回值 * sds ：创建成功返回 sdshdr 相对应的 sds * 创建失败返回 NULL * * 复杂度 * T = O(1) *//* Create an empty (zero length) sds string. Even in this case the string * always has an implicit null term. */sds sdsempty(void) &#123; return sdsnewlen(\"\",0);&#125;/* * 根据给定字符串 init ，创建一个包含同样字符串的 sds * * 参数 * init ：如果输入为 NULL ，那么创建一个空白 sds * 否则，新创建的 sds 中包含和 init 内容相同字符串 * * 返回值 * sds ：创建成功返回 sdshdr 相对应的 sds * 创建失败返回 NULL * * 复杂度 * T = O(N) *//* Create a new sds string starting from a null termined C string. */sds sdsnew(const char *init) &#123; size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);&#125;/* * 复制给定 sds 的副本 * * 返回值 * sds ：创建成功返回输入 sds 的副本 * 创建失败返回 NULL * * 复杂度 * T = O(N) *//* Duplicate an sds string. */sds sdsdup(const sds s) &#123; return sdsnewlen(s, sdslen(s));&#125;/* * 释放给定的 sds * * 复杂度 * T = O(N) *//* Free an sds string. No operation is performed if 's' is NULL. */void sdsfree(sds s) &#123; if (s == NULL) return; zfree(s-sizeof(struct sdshdr));&#125;// 未使用函数，可能已废弃/* Set the sds string length to the length as obtained with strlen(), so * considering as content only up to the first null term character. * * This function is useful when the sds string is hacked manually in some * way, like in the following example: * * s = sdsnew(\"foobar\"); * s[2] = '\\0'; * sdsupdatelen(s); * printf(\"%d\\n\", sdslen(s)); * * The output will be \"2\", but if we comment out the call to sdsupdatelen() * the output will be \"6\" as the string was modified but the logical length * remains 6 bytes. */void sdsupdatelen(sds s) &#123; struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); int reallen = strlen(s); sh-&gt;free += (sh-&gt;len-reallen); sh-&gt;len = reallen;&#125;/* * 在不释放 SDS 的字符串空间的情况下， * 重置 SDS 所保存的字符串为空字符串。 * * 复杂度 * T = O(1) *//* Modify an sds string on-place to make it empty (zero length). * However all the existing buffer is not discarded but set as free space * so that next append operations will not require allocations up to the * number of bytes previously available. */void sdsclear(sds s) &#123; // 取出 sdshdr struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); // 重新计算属性 sh-&gt;free += sh-&gt;len; sh-&gt;len = 0; // 将结束符放到最前面（相当于惰性地删除 buf 中的内容） sh-&gt;buf[0] = '\\0';&#125;/* Enlarge the free space at the end of the sds string so that the caller * is sure that after calling this function can overwrite up to addlen * bytes after the end of the string, plus one more byte for nul term. * * Note: this does not change the *length* of the sds string as returned * by sdslen(), but only the free buffer space we have. *//* * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后， * buf 至少会有 addlen + 1 长度的空余空间 * （额外的 1 字节是为 \\0 准备的） * * 返回值 * sds ：扩展成功返回扩展后的 sds * 扩展失败返回 NULL * * 复杂度 * T = O(N) */sds sdsMakeRoomFor(sds s, size_t addlen) &#123; struct sdshdr *sh, *newsh; // 获取 s 目前的空余空间长度 size_t free = sdsavail(s); size_t len, newlen; // s 目前的空余空间已经足够，无须再进行扩展，直接返回 if (free &gt;= addlen) return s; // 获取 s 目前已占用空间的长度 len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); // s 最少需要的长度 newlen = (len+addlen); // 根据新长度，为 s 分配新空间所需的大小 if (newlen &lt; SDS_MAX_PREALLOC) // 如果新长度小于 SDS_MAX_PREALLOC // 那么为它分配两倍于所需长度的空间 newlen *= 2; else // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC newlen += SDS_MAX_PREALLOC; // T = O(N) newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); // 内存不足，分配失败，返回 if (newsh == NULL) return NULL; // 更新 sds 的空余长度 newsh-&gt;free = newlen - len; // 返回 sds return newsh-&gt;buf;&#125;/* * 回收 sds 中的空闲空间， * 回收不会对 sds 中保存的字符串内容做任何修改。 * * 返回值 * sds ：内存调整后的 sds * * 复杂度 * T = O(N) *//* Reallocate the sds string so that it has no free space at the end. The * contained string remains not altered, but next concatenation operations * will require a reallocation. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */sds sdsRemoveFreeSpace(sds s) &#123; struct sdshdr *sh; sh = (void*) (s-(sizeof(struct sdshdr))); // 进行内存重分配，让 buf 的长度仅仅足够保存字符串内容 // T = O(N) sh = zrealloc(sh, sizeof(struct sdshdr)+sh-&gt;len+1); // 空余空间为 0 sh-&gt;free = 0; return sh-&gt;buf;&#125;/* * 返回给定 sds 分配的内存字节数 * * 复杂度 * T = O(1) *//* Return the total size of the allocation of the specifed sds string, * including: * 1) The sds header before the pointer. * 2) The string. * 3) The free buffer at the end if any. * 4) The implicit null term. */size_t sdsAllocSize(sds s) &#123; struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); return sizeof(*sh)+sh-&gt;len+sh-&gt;free+1;&#125;/* Increment the sds length and decrements the left free space at the * end of the string according to 'incr'. Also set the null term * in the new end of the string. * * 根据 incr 参数，增加 sds 的长度，缩减空余空间， * 并将 \\0 放到新字符串的尾端 * * This function is used in order to fix the string length after the * user calls sdsMakeRoomFor(), writes something after the end of * the current string, and finally needs to set the new length. * * 这个函数是在调用 sdsMakeRoomFor() 对字符串进行扩展， * 然后用户在字符串尾部写入了某些内容之后， * 用来正确更新 free 和 len 属性的。 * * Note: it is possible to use a negative increment in order to * right-trim the string. * * 如果 incr 参数为负数，那么对字符串进行右截断操作。 * * Usage example: * * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the * following schema, to cat bytes coming from the kernel to the end of an * sds string without copying into an intermediate buffer: * * 以下是 sdsIncrLen 的用例： * * oldlen = sdslen(s); * s = sdsMakeRoomFor(s, BUFFER_SIZE); * nread = read(fd, s+oldlen, BUFFER_SIZE); * ... check for nread &lt;= 0 and handle it ... * sdsIncrLen(s, nread); * * 复杂度 * T = O(1) */void sdsIncrLen(sds s, int incr) &#123; struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); // 确保 sds 空间足够 assert(sh-&gt;free &gt;= incr); // 更新属性 sh-&gt;len += incr; sh-&gt;free -= incr; // 这个 assert 其实可以忽略 // 因为前一个 assert 已经确保 sh-&gt;free - incr &gt;= 0 了 assert(sh-&gt;free &gt;= 0); // 放置新的结尾符号 s[sh-&gt;len] = '\\0';&#125;/* Grow the sds to have the specified length. Bytes that were not part of * the original length of the sds will be set to zero. * * if the specified length is smaller than the current length, no operation * is performed. *//* * 将 sds 扩充至指定长度，未使用的空间以 0 字节填充。 * * 返回值 * sds ：扩充成功返回新 sds ，失败返回 NULL * * 复杂度： * T = O(N) */sds sdsgrowzero(sds s, size_t len) &#123; struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); size_t totlen, curlen = sh-&gt;len; // 如果 len 比字符串的现有长度小， // 那么直接返回，不做动作 if (len &lt;= curlen) return s; // 扩展 sds // T = O(N) s = sdsMakeRoomFor(s,len-curlen); // 如果内存不足，直接返回 if (s == NULL) return NULL; /* Make sure added region doesn't contain garbage */ // 将新分配的空间用 0 填充，防止出现垃圾内容 // T = O(N) sh = (void*)(s-(sizeof(struct sdshdr))); memset(s+curlen,0,(len-curlen+1)); /* also set trailing \\0 byte */ // 更新属性 totlen = sh-&gt;len+sh-&gt;free; sh-&gt;len = len; sh-&gt;free = totlen-sh-&gt;len; // 返回新的 sds return s;&#125;/* * 将长度为 len 的字符串 t 追加到 sds 的字符串末尾 * * 返回值 * sds ：追加成功返回新 sds ，失败返回 NULL * * 复杂度 * T = O(N) *//* Append the specified binary-safe string pointed by 't' of 'len' bytes to the * end of the specified sds string 's'. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */sds sdscatlen(sds s, const void *t, size_t len) &#123; struct sdshdr *sh; // 原有字符串长度 size_t curlen = sdslen(s); // 扩展 sds 空间 // T = O(N) s = sdsMakeRoomFor(s,len); // 内存不足？直接返回 if (s == NULL) return NULL; // 复制 t 中的内容到字符串后部 // T = O(N) sh = (void*) (s-(sizeof(struct sdshdr))); memcpy(s+curlen, t, len); // 更新属性 sh-&gt;len = curlen+len; sh-&gt;free = sh-&gt;free-len; // 添加新结尾符号 s[curlen+len] = '\\0'; // 返回新 sds return s;&#125;/* * 将给定字符串 t 追加到 sds 的末尾 * * 返回值 * sds ：追加成功返回新 sds ，失败返回 NULL * * 复杂度 * T = O(N) *//* Append the specified null termianted C string to the sds string 's'. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */sds sdscat(sds s, const char *t) &#123; return sdscatlen(s, t, strlen(t));&#125;/* * 将另一个 sds 追加到一个 sds 的末尾 * * 返回值 * sds ：追加成功返回新 sds ，失败返回 NULL * * 复杂度 * T = O(N) *//* Append the specified sds 't' to the existing sds 's'. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */sds sdscatsds(sds s, const sds t) &#123; return sdscatlen(s, t, sdslen(t));&#125;/* * 将字符串 t 的前 len 个字符复制到 sds s 当中， * 并在字符串的最后添加终结符。 * * 如果 sds 的长度少于 len 个字符，那么扩展 sds * * 复杂度 * T = O(N) * * 返回值 * sds ：复制成功返回新的 sds ，否则返回 NULL *//* Destructively modify the sds string 's' to hold the specified binary * safe string pointed by 't' of length 'len' bytes. */sds sdscpylen(sds s, const char *t, size_t len) &#123; struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); // sds 现有 buf 的长度 size_t totlen = sh-&gt;free+sh-&gt;len; // 如果 s 的 buf 长度不满足 len ，那么扩展它 if (totlen &lt; len) &#123; // T = O(N) s = sdsMakeRoomFor(s,len-sh-&gt;len); if (s == NULL) return NULL; sh = (void*) (s-(sizeof(struct sdshdr))); totlen = sh-&gt;free+sh-&gt;len; &#125; // 复制内容 // T = O(N) memcpy(s, t, len); // 添加终结符号 s[len] = '\\0'; // 更新属性 sh-&gt;len = len; sh-&gt;free = totlen-len; // 返回新的 sds return s;&#125;/* * 将字符串复制到 sds 当中， * 覆盖原有的字符。 * * 如果 sds 的长度少于字符串的长度，那么扩展 sds 。 * * 复杂度 * T = O(N) * * 返回值 * sds ：复制成功返回新的 sds ，否则返回 NULL *//* Like sdscpylen() but 't' must be a null-termined string so that the length * of the string is obtained with strlen(). */sds sdscpy(sds s, const char *t) &#123; return sdscpylen(s, t, strlen(t));&#125;/* Helper for sdscatlonglong() doing the actual number -&gt; string * conversion. 's' must point to a string with room for at least * SDS_LLSTR_SIZE bytes. * * The function returns the lenght of the null-terminated string * representation stored at 's'. */#define SDS_LLSTR_SIZE 21int sdsll2str(char *s, long long value) &#123; char *p, aux; unsigned long long v; size_t l; /* Generate the string representation, this method produces * an reversed string. */ v = (value &lt; 0) ? -value : value; p = s; do &#123; *p++ = '0'+(v%10); v /= 10; &#125; while(v); if (value &lt; 0) *p++ = '-'; /* Compute length and add null term. */ l = p-s; *p = '\\0'; /* Reverse the string. */ p--; while(s &lt; p) &#123; aux = *s; *s = *p; *p = aux; s++; p--; &#125; return l;&#125;/* Identical sdsll2str(), but for unsigned long long type. */int sdsull2str(char *s, unsigned long long v) &#123; char *p, aux; size_t l; /* Generate the string representation, this method produces * an reversed string. */ p = s; do &#123; *p++ = '0'+(v%10); v /= 10; &#125; while(v); /* Compute length and add null term. */ l = p-s; *p = '\\0'; /* Reverse the string. */ p--; while(s &lt; p) &#123; aux = *s; *s = *p; *p = aux; s++; p--; &#125; return l;&#125;/* Create an sds string from a long long value. It is much faster than: * * sdscatprintf(sdsempty(),\"%lld\\n\", value); */// 根据输入的 long long 值 value ，创建一个 SDSsds sdsfromlonglong(long long value) &#123; char buf[SDS_LLSTR_SIZE]; int len = sdsll2str(buf,value); return sdsnewlen(buf,len);&#125;/* * 打印函数，被 sdscatprintf 所调用 * * T = O(N^2) *//* Like sdscatpritf() but gets va_list instead of being variadic. */sds sdscatvprintf(sds s, const char *fmt, va_list ap) &#123; va_list cpy; char staticbuf[1024], *buf = staticbuf, *t; size_t buflen = strlen(fmt)*2; /* We try to start using a static buffer for speed. * If not possible we revert to heap allocation. */ if (buflen &gt; sizeof(staticbuf)) &#123; buf = zmalloc(buflen); if (buf == NULL) return NULL; &#125; else &#123; buflen = sizeof(staticbuf); &#125; /* Try with buffers two times bigger every time we fail to * fit the string in the current buffer size. */ while(1) &#123; buf[buflen-2] = '\\0'; va_copy(cpy,ap); // T = O(N) vsnprintf(buf, buflen, fmt, cpy); if (buf[buflen-2] != '\\0') &#123; if (buf != staticbuf) zfree(buf); buflen *= 2; buf = zmalloc(buflen); if (buf == NULL) return NULL; continue; &#125; break; &#125; /* Finally concat the obtained string to the SDS string and return it. */ t = sdscat(s, buf); if (buf != staticbuf) zfree(buf); return t;&#125;/* * 打印任意数量个字符串，并将这些字符串追加到给定 sds 的末尾 * * T = O(N^2) *//* Append to the sds string 's' a string obtained using printf-alike format * specifier. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. * * Example: * * s = sdsempty(\"Sum is: \"); * s = sdscatprintf(s,\"%d+%d = %d\",a,b,a+b). * * Often you need to create a string from scratch with the printf-alike * format. When this is the need, just use sdsempty() as the target string: * * s = sdscatprintf(sdsempty(), \"... your format ...\", args); */sds sdscatprintf(sds s, const char *fmt, ...) &#123; va_list ap; char *t; va_start(ap, fmt); // T = O(N^2) t = sdscatvprintf(s,fmt,ap); va_end(ap); return t;&#125;/* This function is similar to sdscatprintf, but much faster as it does * not rely on sprintf() family functions implemented by the libc that * are often very slow. Moreover directly handling the sds string as * new data is concatenated provides a performance improvement. * * However this function only handles an incompatible subset of printf-alike * format specifiers: * * %s - C String * %S - SDS string * %i - signed int * %I - 64 bit signed integer (long long, int64_t) * %u - unsigned int * %U - 64 bit unsigned integer (unsigned long long, uint64_t) * %% - Verbatim \"%\" character. */sds sdscatfmt(sds s, char const *fmt, ...) &#123; struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); size_t initlen = sdslen(s); const char *f = fmt; int i; va_list ap; va_start(ap,fmt); f = fmt; /* Next format specifier byte to process. */ i = initlen; /* Position of the next byte to write to dest str. */ while(*f) &#123; char next, *str; size_t l; long long num; unsigned long long unum; /* Make sure there is always space for at least 1 char. */ if (sh-&gt;free == 0) &#123; s = sdsMakeRoomFor(s,1); sh = (void*) (s-(sizeof(struct sdshdr))); &#125; switch(*f) &#123; case '%': next = *(f+1); f++; switch(next) &#123; case 's': case 'S': str = va_arg(ap,char*); l = (next == 's') ? strlen(str) : sdslen(str); if (sh-&gt;free &lt; l) &#123; s = sdsMakeRoomFor(s,l); sh = (void*) (s-(sizeof(struct sdshdr))); &#125; memcpy(s+i,str,l); sh-&gt;len += l; sh-&gt;free -= l; i += l; break; case 'i': case 'I': if (next == 'i') num = va_arg(ap,int); else num = va_arg(ap,long long); &#123; char buf[SDS_LLSTR_SIZE]; l = sdsll2str(buf,num); if (sh-&gt;free &lt; l) &#123; s = sdsMakeRoomFor(s,l); sh = (void*) (s-(sizeof(struct sdshdr))); &#125; memcpy(s+i,buf,l); sh-&gt;len += l; sh-&gt;free -= l; i += l; &#125; break; case 'u': case 'U': if (next == 'u') unum = va_arg(ap,unsigned int); else unum = va_arg(ap,unsigned long long); &#123; char buf[SDS_LLSTR_SIZE]; l = sdsull2str(buf,unum); if (sh-&gt;free &lt; l) &#123; s = sdsMakeRoomFor(s,l); sh = (void*) (s-(sizeof(struct sdshdr))); &#125; memcpy(s+i,buf,l); sh-&gt;len += l; sh-&gt;free -= l; i += l; &#125; break; default: /* Handle %% and generally %&lt;unknown&gt;. */ s[i++] = next; sh-&gt;len += 1; sh-&gt;free -= 1; break; &#125; break; default: s[i++] = *f; sh-&gt;len += 1; sh-&gt;free -= 1; break; &#125; f++; &#125; va_end(ap); /* Add null-term */ s[i] = '\\0'; return s;&#125;/* * 对 sds 左右两端进行修剪，清除其中 cset 指定的所有字符 * * 比如 sdsstrim(xxyyabcyyxy, \"xy\") 将返回 \"abc\" * * 复杂性： * T = O(M*N)，M 为 SDS 长度， N 为 cset 长度。 *//* Remove the part of the string from left and from right composed just of * contiguous characters found in 'cset', that is a null terminted C string. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. * * Example: * * s = sdsnew(\"AA...AA.a.aa.aHelloWorld :::\"); * s = sdstrim(s,\"A. :\"); * printf(\"%s\\n\", s); * * Output will be just \"Hello World\". */sds sdstrim(sds s, const char *cset) &#123; struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); char *start, *end, *sp, *ep; size_t len; // 设置和记录指针 sp = start = s; ep = end = s+sdslen(s)-1; // 修剪, T = O(N^2) while(sp &lt;= end &amp;&amp; strchr(cset, *sp)) sp++; while(ep &gt; start &amp;&amp; strchr(cset, *ep)) ep--; // 计算 trim 完毕之后剩余的字符串长度 len = (sp &gt; ep) ? 0 : ((ep-sp)+1); // 如果有需要，前移字符串内容 // T = O(N) if (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len); // 添加终结符 sh-&gt;buf[len] = '\\0'; // 更新属性 sh-&gt;free = sh-&gt;free+(sh-&gt;len-len); sh-&gt;len = len; // 返回修剪后的 sds return s;&#125;/* * 按索引对截取 sds 字符串的其中一段 * start 和 end 都是闭区间（包含在内） * * 索引从 0 开始，最大为 sdslen(s) - 1 * 索引可以是负数， sdslen(s) - 1 == -1 * * 复杂度 * T = O(N) *//* Turn the string into a smaller (or equal) string containing only the * substring specified by the 'start' and 'end' indexes. * * start and end can be negative, where -1 means the last character of the * string, -2 the penultimate character, and so forth. * * The interval is inclusive, so the start and end characters will be part * of the resulting string. * * The string is modified in-place. * * Example: * * s = sdsnew(\"Hello World\"); * sdsrange(s,1,-1); =&gt; \"ello World\" */void sdsrange(sds s, int start, int end) &#123; struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); size_t newlen, len = sdslen(s); if (len == 0) return; if (start &lt; 0) &#123; start = len+start; if (start &lt; 0) start = 0; &#125; if (end &lt; 0) &#123; end = len+end; if (end &lt; 0) end = 0; &#125; newlen = (start &gt; end) ? 0 : (end-start)+1; if (newlen != 0) &#123; if (start &gt;= (signed)len) &#123; newlen = 0; &#125; else if (end &gt;= (signed)len) &#123; end = len-1; newlen = (start &gt; end) ? 0 : (end-start)+1; &#125; &#125; else &#123; start = 0; &#125; // 如果有需要，对字符串进行移动 // T = O(N) if (start &amp;&amp; newlen) memmove(sh-&gt;buf, sh-&gt;buf+start, newlen); // 添加终结符 sh-&gt;buf[newlen] = 0; // 更新属性 sh-&gt;free = sh-&gt;free+(sh-&gt;len-newlen); sh-&gt;len = newlen;&#125;/* * 将 sds 字符串中的所有字符转换为小写 * * T = O(N) *//* Apply tolower() to every character of the sds string 's'. */void sdstolower(sds s) &#123; int len = sdslen(s), j; for (j = 0; j &lt; len; j++) s[j] = tolower(s[j]);&#125;/* * 将 sds 字符串中的所有字符转换为大写 * * T = O(N) *//* Apply toupper() to every character of the sds string 's'. */void sdstoupper(sds s) &#123; int len = sdslen(s), j; for (j = 0; j &lt; len; j++) s[j] = toupper(s[j]);&#125;/* * 对比两个 sds ， strcmp 的 sds 版本 * * 返回值 * int ：相等返回 0 ，s1 较大返回正数， s2 较大返回负数 * * T = O(N) *//* Compare two sds strings s1 and s2 with memcmp(). * * Return value: * * 1 if s1 &gt; s2. * -1 if s1 &lt; s2. * 0 if s1 and s2 are exactly the same binary string. * * If two strings share exactly the same prefix, but one of the two has * additional characters, the longer string is considered to be greater than * the smaller one. */int sdscmp(const sds s1, const sds s2) &#123; size_t l1, l2, minlen; int cmp; l1 = sdslen(s1); l2 = sdslen(s2); minlen = (l1 &lt; l2) ? l1 : l2; cmp = memcmp(s1,s2,minlen); if (cmp == 0) return l1-l2; return cmp;&#125;/* Split 's' with separator in 'sep'. An array * of sds strings is returned. *count will be set * by reference to the number of tokens returned. * * 使用分隔符 sep 对 s 进行分割，返回一个 sds 字符串的数组。 * *count 会被设置为返回数组元素的数量。 * * On out of memory, zero length string, zero length * separator, NULL is returned. * * 如果出现内存不足、字符串长度为 0 或分隔符长度为 0 * 的情况，返回 NULL * * Note that 'sep' is able to split a string using * a multi-character separator. For example * sdssplit(\"foo_-_bar\",\"_-_\"); will return two * elements \"foo\" and \"bar\". * * 注意分隔符可以的是包含多个字符的字符串 * * This version of the function is binary-safe but * requires length arguments. sdssplit() is just the * same function but for zero-terminated strings. * * 这个函数接受 len 参数，因此它是二进制安全的。 * （文档中提到的 sdssplit() 已废弃） * * T = O(N^2) */sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) &#123; int elements = 0, slots = 5, start = 0, j; sds *tokens; if (seplen &lt; 1 || len &lt; 0) return NULL; tokens = zmalloc(sizeof(sds)*slots); if (tokens == NULL) return NULL; if (len == 0) &#123; *count = 0; return tokens; &#125; // T = O(N^2) for (j = 0; j &lt; (len-(seplen-1)); j++) &#123; /* make sure there is room for the next element and the final one */ if (slots &lt; elements+2) &#123; sds *newtokens; slots *= 2; newtokens = zrealloc(tokens,sizeof(sds)*slots); if (newtokens == NULL) goto cleanup; tokens = newtokens; &#125; /* search the separator */ // T = O(N) if ((seplen == 1 &amp;&amp; *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) &#123; tokens[elements] = sdsnewlen(s+start,j-start); if (tokens[elements] == NULL) goto cleanup; elements++; start = j+seplen; j = j+seplen-1; /* skip the separator */ &#125; &#125; /* Add the final element. We are sure there is room in the tokens array. */ tokens[elements] = sdsnewlen(s+start,len-start); if (tokens[elements] == NULL) goto cleanup; elements++; *count = elements; return tokens;cleanup: &#123; int i; for (i = 0; i &lt; elements; i++) sdsfree(tokens[i]); zfree(tokens); *count = 0; return NULL; &#125;&#125;/* * 释放 tokens 数组中 count 个 sds * * T = O(N^2) *//* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */void sdsfreesplitres(sds *tokens, int count) &#123; if (!tokens) return; while(count--) sdsfree(tokens[count]); zfree(tokens);&#125;/* * 将长度为 len 的字符串 p 以带引号（quoted）的格式 * 追加到给定 sds 的末尾 * * T = O(N) *//* Append to the sds string \"s\" an escaped string representation where * all the non-printable characters (tested with isprint()) are turned into * escapes in the form \"\\n\\r\\a....\" or \"\\x&lt;hex-number&gt;\". * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */sds sdscatrepr(sds s, const char *p, size_t len) &#123; s = sdscatlen(s,\"\\\"\",1); while(len--) &#123; switch(*p) &#123; case '\\\\': case '\"': s = sdscatprintf(s,\"\\\\%c\",*p); break; case '\\n': s = sdscatlen(s,\"\\\\n\",2); break; case '\\r': s = sdscatlen(s,\"\\\\r\",2); break; case '\\t': s = sdscatlen(s,\"\\\\t\",2); break; case '\\a': s = sdscatlen(s,\"\\\\a\",2); break; case '\\b': s = sdscatlen(s,\"\\\\b\",2); break; default: if (isprint(*p)) s = sdscatprintf(s,\"%c\",*p); else s = sdscatprintf(s,\"\\\\x%02x\",(unsigned char)*p); break; &#125; p++; &#125; return sdscatlen(s,\"\\\"\",1);&#125;/* Helper function for sdssplitargs() that returns non zero if 'c' * is a valid hex digit. *//* * 如果 c 为十六进制符号的其中一个，返回正数 * * T = O(1) */int is_hex_digit(char c) &#123; return (c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F');&#125;/* Helper function for sdssplitargs() that converts a hex digit into an * integer from 0 to 15 *//* * 将十六进制符号转换为 10 进制 * * T = O(1) */int hex_digit_to_int(char c) &#123; switch(c) &#123; case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9; case 'a': case 'A': return 10; case 'b': case 'B': return 11; case 'c': case 'C': return 12; case 'd': case 'D': return 13; case 'e': case 'E': return 14; case 'f': case 'F': return 15; default: return 0; &#125;&#125;/* Split a line into arguments, where every argument can be in the * following programming-language REPL-alike form: * * 将一行文本分割成多个参数，每个参数可以有以下的类编程语言 REPL 格式： * * foo bar \"newline are supported\\n\" and \"\\xff\\x00otherstuff\" * * The number of arguments is stored into *argc, and an array * of sds is returned. * * 参数的个数会保存在 *argc 中，函数返回一个 sds 数组。 * * The caller should free the resulting array of sds strings with * sdsfreesplitres(). * * 调用者应该使用 sdsfreesplitres() 来释放函数返回的 sds 数组。 * * Note that sdscatrepr() is able to convert back a string into * a quoted string in the same format sdssplitargs() is able to parse. * * sdscatrepr() 可以将一个字符串转换为一个带引号（quoted）的字符串， * 这个带引号的字符串可以被 sdssplitargs() 分析。 * * The function returns the allocated tokens on success, even when the * input string is empty, or NULL if the input contains unbalanced * quotes or closed quotes followed by non space characters * as in: \"foo\"bar or \"foo' * * 即使输入出现空字符串， NULL ，或者输入带有未对应的括号， * 函数都会将已成功处理的字符串先返回。 * * 这个函数主要用于 config.c 中对配置文件进行分析。 * 例子： * sds *arr = sdssplitargs(\"timeout 10086\\r\\nport 123321\\r\\n\"); * 会得出 * arr[0] = \"timeout\" * arr[1] = \"10086\" * arr[2] = \"port\" * arr[3] = \"123321\" * * T = O(N^2) */sds *sdssplitargs(const char *line, int *argc) &#123; const char *p = line; char *current = NULL; char **vector = NULL; *argc = 0; while(1) &#123; /* skip blanks */ // 跳过空白 // T = O(N) while(*p &amp;&amp; isspace(*p)) p++; if (*p) &#123; /* get a token */ int inq=0; /* set to 1 if we are in \"quotes\" */ int insq=0; /* set to 1 if we are in 'single quotes' */ int done=0; if (current == NULL) current = sdsempty(); // T = O(N) while(!done) &#123; if (inq) &#123; if (*p == '\\\\' &amp;&amp; *(p+1) == 'x' &amp;&amp; is_hex_digit(*(p+2)) &amp;&amp; is_hex_digit(*(p+3))) &#123; unsigned char byte; byte = (hex_digit_to_int(*(p+2))*16)+ hex_digit_to_int(*(p+3)); current = sdscatlen(current,(char*)&amp;byte,1); p += 3; &#125; else if (*p == '\\\\' &amp;&amp; *(p+1)) &#123; char c; p++; switch(*p) &#123; case 'n': c = '\\n'; break; case 'r': c = '\\r'; break; case 't': c = '\\t'; break; case 'b': c = '\\b'; break; case 'a': c = '\\a'; break; default: c = *p; break; &#125; current = sdscatlen(current,&amp;c,1); &#125; else if (*p == '\"') &#123; /* closing quote must be followed by a space or * nothing at all. */ if (*(p+1) &amp;&amp; !isspace(*(p+1))) goto err; done=1; &#125; else if (!*p) &#123; /* unterminated quotes */ goto err; &#125; else &#123; current = sdscatlen(current,p,1); &#125; &#125; else if (insq) &#123; if (*p == '\\\\' &amp;&amp; *(p+1) == '\\'') &#123; p++; current = sdscatlen(current,\"'\",1); &#125; else if (*p == '\\'') &#123; /* closing quote must be followed by a space or * nothing at all. */ if (*(p+1) &amp;&amp; !isspace(*(p+1))) goto err; done=1; &#125; else if (!*p) &#123; /* unterminated quotes */ goto err; &#125; else &#123; current = sdscatlen(current,p,1); &#125; &#125; else &#123; switch(*p) &#123; case ' ': case '\\n': case '\\r': case '\\t': case '\\0': done=1; break; case '\"': inq=1; break; case '\\'': insq=1; break; default: current = sdscatlen(current,p,1); break; &#125; &#125; if (*p) p++; &#125; /* add the token to the vector */ // T = O(N) vector = zrealloc(vector,((*argc)+1)*sizeof(char*)); vector[*argc] = current; (*argc)++; current = NULL; &#125; else &#123; /* Even on empty input string return something not NULL. */ if (vector == NULL) vector = zmalloc(sizeof(void*)); return vector; &#125; &#125;err: while((*argc)--) sdsfree(vector[*argc]); zfree(vector); if (current) sdsfree(current); *argc = 0; return NULL;&#125;/* Modify the string substituting all the occurrences of the set of * characters specified in the 'from' string to the corresponding character * in the 'to' array. * * 将字符串 s 中， * 所有在 from 中出现的字符，替换成 to 中的字符 * * For instance: sdsmapchars(mystring, \"ho\", \"01\", 2) * will have the effect of turning the string \"hello\" into \"0ell1\". * * 比如调用 sdsmapchars(mystring, \"ho\", \"01\", 2) * 就会将 \"hello\" 转换为 \"0ell1\" * * The function returns the sds string pointer, that is always the same * as the input pointer since no resize is needed. * 因为无须对 sds 进行大小调整， * 所以返回的 sds 输入的 sds 一样 * * T = O(N^2) */sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) &#123; size_t j, i, l = sdslen(s); // 遍历输入字符串 for (j = 0; j &lt; l; j++) &#123; // 遍历映射 for (i = 0; i &lt; setlen; i++) &#123; // 替换字符串 if (s[j] == from[i]) &#123; s[j] = to[i]; break; &#125; &#125; &#125; return s;&#125;/* Join an array of C strings using the specified separator (also a C string). * Returns the result as an sds string. */sds sdsjoin(char **argv, int argc, char *sep) &#123; sds join = sdsempty(); int j; for (j = 0; j &lt; argc; j++) &#123; join = sdscat(join, argv[j]); if (j != argc-1) join = sdscat(join,sep); &#125; return join;&#125;","path":"2019/04/15/redis原码-sds/","date":"04-15","excerpt":"","tags":[{"name":"源码","slug":"源码","permalink":"https://jijiking51.cn/tags/源码/"},{"name":"sds","slug":"sds","permalink":"https://jijiking51.cn/tags/sds/"}],"preview":"http://img.jijiking51.cn/redis%E5%8E%9F%E7%A0%81_sds.jpg"},{"title":"deepin开机后假死","text":"思路参考：https://blog.csdn.net/fdqw_sph/article/details/78759529 首先，我的电脑是显卡和Linux不兼容（多种版本Linux，例如：manjaro三个版本均无法使用，Ubuntu除17.10之外均无法使用——17.10还无法正常关机，需要手动关闭所有软件才可以关机，deepin开机登陆后假死，dock无反应，单cpu飙升100，kill不掉那个100%的进程） 今天折腾了一下黑苹果无果，然后回来试试deepin 看了很多官方论坛后肯定了我的显卡问题（其实主要是主板LZ，无法禁用独显） 知道原因了就问了Google 发现了上面这个大佬的帖子， 话不多说： 1.下载对应的显卡驱动https://www.geforce.cn/drivers 2.（最关键的地方） 1lsmod | grep nouveau 如果有输出则代表nouveau正在加载。则需要禁用nouveau，在/etc/modprobe.d中创建文件blacklist-nouveau.conf，再用getid打开 123cd /etc/modprobe.d/etc/modprobe.d$ sudo touch blacklist-nouveau.confsudo gedit blacklist-nouveau.conf 在文件中输入以下内容并保存： 12blacklist nouveau options nouveau modeset=0 然后更新 1sudo update-initramfs -u 这种方式也可能不能彻底禁用nouveau，在此基础上可以移除以下文件：nouveau.ko；nouveau.ko.org，此文件一般是隐藏的具体操作 123456789101112131415cd /lib/modules/4.14.0-deepin2-amd64/kernel/drivers/gpu/drm/nouveau sudo rm -rf nouveau.ko sudo rm -rf nouveau.ko.org/* * 我这里有两个选项在 &gt; /lib/modules$ ls &gt; 4.14.0-deepin2-amd64 4.9.0-deepin13-amd64 * 注意，我也不知道要删除哪个才管用，只好两个的都删除了 * /cd /lib/modules/4.9.0-deepin13-amd64/kernel/drivers/gpu/drm/nouveau sudo rm -rf nouveau.ko sudo rm -rf nouveau.ko.org 继续更新下 1sudo update-initramfs –u 重启，也许你现在运行reboot或者shutdown会死机， 不过没关系， 强制关机就好 开机运行 1lsmod | grep nouveau 如果没输出，那就是禁用成功 重启 不用输入密码，开机按Ctrl + Alt + F2输入用户名，密码，进入下载NVIDIA的目录下 1sudo sh XXXXXXXXXXXXXXXX.run 重启 然后就可以使用了。 本教程也许只对我一个人有用","path":"2019/04/11/deepin开机后假死/","date":"04-11","excerpt":"","tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://jijiking51.cn/tags/踩坑/"},{"name":"deepin","slug":"deepin","permalink":"https://jijiking51.cn/tags/deepin/"}],"preview":"http://img.jijiking51.cn/deepin开机后假死.jpg"},{"title":"Python深复制和浅复制","text":"python中赋值是引用传递——&gt;例子中的 c 复制要使用copy浅复制（浅拷贝）是复制对象本身，并不对对象内部的子对象进行复制。——&gt;例子中的b深复制（深拷贝）将对象的本身以及子对象全部拷贝——&gt;例子中的d 12345678910111213141516171819202122232425262728293031323334353637#初始对象a = [1,2,3,4,5,6,[0,0,0,0]]#b 进行浅赋值b = copy.copy(a)#c 直接引用ac = a#d进行深度复制d = copy.deepcopy(a)&quot;&quot;&quot; a 中添加新的元素 受影响的有c&quot;&quot;&quot;a.append(7)&quot;&quot;&quot; a的子对象中添加新的元素 受影响的有 b ，c&quot;&quot;&quot;a[6].append(1)print(a)print(b)print(c)print(d)&quot;&quot;&quot;[1, 2, 3, 4, 5, 6, [0, 0, 0, 0, 1], 7][1, 2, 3, 4, 5, 6, [0, 0, 0, 0, 1]][1, 2, 3, 4, 5, 6, [0, 0, 0, 0, 1], 7][1, 2, 3, 4, 5, 6, [0, 0, 0, 0]]&quot;&quot;&quot;","path":"2019/04/11/Python深复制和浅复制/","date":"04-11","excerpt":"","tags":[{"name":"基础","slug":"基础","permalink":"https://jijiking51.cn/tags/基础/"}],"preview":"http://img.jijiking51.cn/Python 深复制和浅复制.jpg"},{"title":"python连接mysql","text":"首先安装mysql驱动 1pip3 install mysql-connector-python --allow-external mysql-connector-python mysql连接实例：123456789101112131415161718192021#加载驱动import mysql.connector#建立连接conn = mysql.connector.connect(user=&apos;root&apos;,password=&apos;123456&apos;,database=&apos;school&apos;)#获取连接的游标cursor = conn.cursor()#执行Sqlcursor.execute(&quot;show tables&quot;)#获取返回列表（list）a = cursor.fetchall()#遍历for i in a: print(re.match(tables_name,str(i)).group(1))#关闭游标cursor.close()#提交未提交事物conn.commit()#关闭连接conn.close() 使用sqlalchemy对数据库生成映射对象安装驱动 1pip3 install sqlalchemy sqlalchemy使用实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from sqlalchemy import Column , String , create_enginefrom sqlalchemy.orm import sessionmakerfrom sqlalchemy.ext.declarative import declarative_base#创建一个对象的基类Base = declarative_base()#创建对象class User(Base): &quot;&quot;&quot;Test for sqlalachemy&quot;&quot;&quot; #数据库表名 __tablename__ = &apos;students&apos; #表的结构 &apos;&apos;&apos; +----------+----------------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +----------+----------------------------------------------------------------------------------------------------------------------------------------------------------+ | students | CREATE TABLE `students` ( `sid` varchar(10) NOT NULL, `sname` varchar(10) DEFAULT NULL, PRIMARY KEY (`sid`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1 | +----------+----------------------------------------------------------------------------------------------------------------------------------------------------------+ &apos;&apos;&apos; sid = Column(String(10),primary_key=True) sname = Column(String(10))#创建连接 格式： 数据库类型+数据库驱动名称://用户名：密码@及其地址:端口/数据库名字engine = create_engine(&apos;mysql+mysqlconnector://root:123456@localhost:3306/school&apos;)#创建DBSession类型DBSession = sessionmaker(bind=engine)#建立连接session = DBSession()# 创建新的对象new_user = User(sid = &apos;5&apos;,sname = &apos;Bob&apos;)# 添加到sessionsession.add(new_user)# 提交事物session.commit()# 关闭连接session.close() 利用sqlalchemy将数据内容映射到User对象 12345678910111213141516171819202122232425from sqlalchemy import Column ,String,create_enginefrom sqlalchemy.orm import sessionmakerfrom sqlalchemy.ext.declarative import declarative_baseBase = declarative_base()class User(Base): __tablename__ = &apos;students&apos; sid = Column(String(10),primary_key = True) sname = Column(String(10))engine = create_engine(&apos;mysql+mysqlconnector://root:123456@localhost:3306/school&apos;)DBSession = sessionmaker(bind = engine)session = DBSession()#创建Query查询，filter是where条件，最后是返回一行， 如果是all()则返回所有行#此处 session.query(User).filter(User.sid == &apos;5&apos;).one()#如果是多表查询可以是#session.query(User,address).filter(User.sid == address.sid).one()user = session.query(User).filter(User.sid==&apos;5&apos;).one()print(&apos;type:&apos;,type(user))print(&apos;name:&apos;,user.sname)session.close()","path":"2019/04/11/python连接mysql/","date":"04-11","excerpt":"","tags":[{"name":"基础","slug":"基础","permalink":"https://jijiking51.cn/tags/基础/"}],"preview":"http://img.jijiking51.cn/python连接mysql.jpg"},{"title":"Django2.0使用","text":"准备 首先下载安装django 1pip3 install django pycharm可以直接建立django的项目，也可以执行命令 1django-admin startproject mysite 这样就建立了一个mysite的django项目。 下面是新建项目的目录文件列表1234567mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 其中，settings.py是项目各种配置的文件urls.py是url目录文件manage.py是管理工具 尝试运行（pycharm可以直接点击Django项目运行）也可以shell运行命令 1234567891011121314python manage.py runserver运行成功后的输出Performing system checks...System check identified no issues (0 silenced).You have unapplied migrations; your app may not work properly until they are applied.Run &apos;python manage.py migrate&apos; to apply them.六月 01, 2018 - 15:50:53Django version 2.0, using settings &apos;mysite.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 2.创建一个应用1python manage.py startapp polls 创建完成后会在mysite目录下看到一个polls文件目录 123456789polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 应用创建完成了不过，等下模型的学习中还要使用 3.视图现在创建我们的第一个视图应用 12345from django.http import HttpResponse,request# Create your views here.def hello(request): html = &apos;&lt;html&gt;&lt;body&gt;hello world&lt;/body&gt;&lt;/heml&gt;&apos; return HttpResponse(html) 同时配置我们的polls/urls.py 12345678910111213添加：path(&quot;&quot;,views.hello,name=&apos;index&apos;)完成后是这个样子：from django.urls import path,includefrom . import viewsurlpatterns =[ #首页设置 path(&quot;&quot;,views.hello,name=&apos;index&apos;),] 这仅仅是polls下的配置，mysite还无法知道这是什么意思，所以我们还要配置mysite/urls.py打开mysite/urls.py后里面已经有内容了，在其中添加 123456789101112path(&apos;polls/&apos;,include(&apos;polls.urls&apos;)),配置好以后的样子from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path(&apos;admin/&apos;, admin.site.urls), path(&apos;polls/&apos;,include(&apos;polls.urls&apos;)),] 然后就可以打开浏览器输入链接：http://127.0.0.1:8000/polls/ 这里面用到了include在官方文档中是这样写的： 函数 include() 允许引用其它 URLconfs。每当 Django 遇到 :func：~django.urls.include时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到 URLconf 以供进一步处理。 我们设计 include()的理念是使其可以即插即用。因为投票应用有它自己的 URLconf( polls/urls.py )，他们能够被放在 “/polls/“ ，“/fun_polls/“ ，”/content/polls/“，或者其他任何路径下，这个应用都能够正常工作。 接下来理解一下path： 1234567891011121314151617def _path(route, view, kwargs=None, name=None, Pattern=None): if isinstance(view, (list, tuple)): # For include(...) processing. pattern = Pattern(route, is_endpoint=False) urlconf_module, app_name, namespace = view return URLResolver( pattern, urlconf_module, kwargs, app_name=app_name, namespace=namespace, ) elif callable(view): pattern = Pattern(route, name=name, is_endpoint=True) return URLPattern(pattern, view, kwargs, name) else: raise TypeError(&apos;view must be a callable or a list/tuple in the case of include().&apos;) 这是path的函数，我们可以看到传递进去的参数： route：route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。view：当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。kwargs=None：任意个关键字参数可以作为一个字典传递给目标视图函数 name=None：为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。 Pattern=None：官方文档并没有给解释 其中，博主也只知道使用route和view，设置name之后怎么使用name博主也不知道，如果哪位大大翻了博主的牌，望告知 4.数据库配置python默认使用的是SQLite，但是博主使用的是mysql，所以接下来都是mysql的配置，如果是其他数据库请看官方文档在此之前，请确认：1.安装好mysql数据库2.已经下载好了mysqlclient（pip/pip3 install mysqlclient）3.设置好时间在mysite/settings.pyTIME_ZONE = ‘Asia/Shanghai’ 看到下面的内容， 我们打开mysite/settings.py sqlite：’django.db.backends.sqlite3’postgresql：’django.db.backends.postgresql’mysql：’django.db.backends.mysql‘oracle：’django.db.backends.oracle’ 找到DATABASES这个设置，填写以下内容 12345678910DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;polls&apos;, &apos;USER&apos;: &apos;root&apos;, &apos;PASSWORD&apos;: &apos;123456&apos;, &apos;HOST&apos;: &apos;127.0.0.1&apos;, &apos;PORT&apos;: &apos;3306&apos;, &#125;&#125; NAME： 数据库名字USER：用户名PASSWORD：用户密码HOST：ipPORT：端口 在创建自己的模型之前，我们先运行 1python manage.py migrate 这是为为我们的admin应用创建数据库表格 接下来编写我们的模型： 打开polls/models.py，填写以下代码： 12345678910from django.db import models# Create your models here.class Question(models.Model): question_text = models.CharField(max_length=200) pub_data = models.DateTimeField(&apos;date published&apos;)class Choice(models.Model): question = models.ForeignKey(Question,on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 这里，将每一个类表示未django.db.modles.Model的子类，每个模型都有一些变量， 这是表示模型里面的数据库的字段每个字段我们都设置了一个类型， 比如CharField,DateTImeFIeld,用来告诉django处理数据的类型。其中我们定义了一个Field名字，在官方文档中， 他是这样解释的： 你可以使用可选的选项来为 Field 定义一个人类可读的名字。这个功能在很多 Django内部组成部分中都被使用了，而且作为文档的一部分。如果某个字段没有提供此名称，Django将会使用对机器友好的名称，也就是变量名。在上面的例子中，我们只为 Question.pub_date定义了对人类友好的名字。对于模型内的其它字段，它们的机器友好名也会被作为人类友好名使用。 Field中有些参数，例如 max_length 这个浅显易懂，就是长度设置，当然也可以设置默认值，例如 :default = 0最后我们定义了ForeignKey，这是一对一关系， 告诉我们每个choice都对应了一个question，后面的参数是：models.CASCADE：对就对象删除后，包含ForeignKey的字段也会被删除models.PROTECT：删除时会引起ProtectedErrormodels.SET_NULL：注意只有当当前字段设置null设置为True才有效，此情况会将ForeignKey字段设置为nullmodels.SET_DEFAULT ：同样，当前字段设置了default才有效，此情况会将ForeignKey 字段设置为default 值moels.SET：此时需要指定set的值models.DO_NOTHING ：什么也不做 写好模型之后我们要去激活我们的模型，在mysite/settings.py中找到这个INSTALLED_APPS在里面添加 12#因为PollsConfig类写在了polls/apps中’polls.apps.PollsConfig‘ 接着，我们运行以下命令： 1234567891011121314151617181920212223242526272829#通过运行 makemigrations 命令，Django 会检测你对模型文件的修改（在这种情况下，你已经取得了新的），并且把修改的部分储存为一次 迁移。python manage.py makemigrations polls#输出Migrations for &apos;polls&apos;: polls/migrations/0001_initial.py: - Create model Choice - Create model Question - Add field question to choice#查看迁移执行的命令python manage.py sqlmigrate polls 0001#输出BEGIN;---- Create model Choice--CREATE TABLE `polls_choice` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `choice_text` varchar(200) NOT NULL, `votes` integer NOT NULL);---- Create model Question--CREATE TABLE `polls_question` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `question_text` varchar(200) NOT NULL, `pub_data` datetime(6) NOT NULL);---- Add field question to choice--ALTER TABLE `polls_choice` ADD COLUMN `question_id` integer NOT NULL;ALTER TABLE `polls_choice` ADD CONSTRAINT `polls_choice_question_id_c5b4b260_fk_polls_question_id` FOREIGN KEY (`question_id`) REFERENCES `polls_question` (`id`);COMMIT; 关于迁移和官方文档的提醒要点： 1、迁移是 Django 对于模型定义（也就是你的数据库结构）的变化的储存形式 - 没那么玄乎，它们其实也只是一些你磁盘上的文件。如果你想的话，你可以阅读一下你模型的迁移数据，它被储存在 polls/migrations/0001_initial.py 里。别担心，你不需要每次都阅读迁移文件，但是它们被设计成人类可读的形式，这是为了便于你手动修改它们。 2、注意要点： 输出的内容和你使用的数据库有关，上面的输出示例使用的是 PostgreSQL。 数据库的表名是由应用名(polls)和模型名的小写形式( question 和 choice)连接而来。（如果需要，你可以自定义此行为。） 主键(IDs)会被自动创建。(当然，你也可以自定义。) 默认的，Django 会在外键字段名后追加字符串 “_id” 。（同样，这也可以自定义。） 外键关系由 FOREIGN KEY 生成。你不用关心 DEFERRABLE 部分，它只是告诉 PostgreSQL，请在事务全都执行完之后再创建外键关系。 生成的 SQL 语句是为你所用的数据库定制的，所以那些和数据库有关的字段类型，比如 auto_increment (MySQL)、 serial (PostgreSQL)和 integer primary key autoincrement (SQLite)，Django 会帮你自动处理。那些和引号相关的事情 - 例如，是使用单引号还是双引号 - 也一样会被自动处理。 这个 sqlmigrate 命令并没有真正在你的数据库中的执行迁移 - 它只是把命令输出到屏幕上，让你看看 Django 认为需要执行哪些 SQL 语句。这在你想看看 Django 到底准备做什么，或者当你是数据库管理员，需要写脚本来批量处理数据库时会很有用。 再次执行命令： 12345678python manage.py migrate#输出Operations to perform: Apply all migrations: admin, auth, contenttypes, polls, sessionsRunning migrations: Rendering model states... DONE Applying polls.0001_initial... OK 这样，数据库中就自动创建了表格 总结： 编辑 models.py 文件，改变模型。 运行 python manage.py makemigrations 为模型的改变生成迁移文件。 运行 python manage.py migrate 来应用数据库迁移。 5.API使用*此段直接引用于官方文档 12345678910111213141516171819202122232425262728293031323334$ python manage.py shell&gt;&gt;&gt; from polls.models import Choice, Question # Import the model classes we just wrote.# No questions are in the system yet.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet []&gt;# Create a new Question.# Support for time zones is enabled in the default settings file, so# Django expects a datetime with tzinfo for pub_date. Use timezone.now()# instead of datetime.datetime.now() and it will do the right thing.&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; q = Question(question_text=&quot;What&apos;s new?&quot;, pub_date=timezone.now())# Save the object into the database. You have to call save() explicitly.&gt;&gt;&gt; q.save()# Now it has an ID.&gt;&gt;&gt; q.id1# Access model field values via Python attributes.&gt;&gt;&gt; q.question_text&quot;What&apos;s new?&quot;&gt;&gt;&gt; q.pub_datedatetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=&lt;UTC&gt;)# Change values by changing the attributes, then calling save().&gt;&gt;&gt; q.question_text = &quot;What&apos;s up?&quot;&gt;&gt;&gt; q.save()# objects.all() displays all the questions in the database.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: Question object (1)&gt;]&gt; Question object(1)对于我们了解这个对象的细节没什么帮助。让我们通过编辑 Question 模型的代码（位于 polls/models.py 中）来修复这个问题。给 Question 和 Choice 增加 str() 方法。polls/models.py 1234567891011from django.db import modelsclass Question(models.Model): # ... def __str__(self): return self.question_textclass Choice(models.Model): # ... def __str__(self): return self.choice_text 给模型增加 str() 方法是很重要的，这不仅仅能给你在命令行里使用带来方便，Django 自动生成的 admin 里也使用这个方法来表示对象。 注意：这些都是常规的 Python方法。让我们添加一个自定义的方法，这只是为了演示：polls/models.py 12345678910import datetimefrom django.db import modelsfrom django.utils import timezoneclass Question(models.Model): # ... def was_published_recently(self): return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1) 新加入的 import datetime 和 from django.utils import timezone 分别导入了 Python 的标准 datetime 模块和 Django 中和时区相关的 django.utils.timezone 工具模块。如果你不太熟悉 Python 中的时区处理，看看 时区支持文档 吧。 保存文件然后通过 python manage.py shell 命令再次打开 Python 交互式命令行： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&gt;&gt;&gt; from polls.models import Choice, Question# Make sure our __str__() addition worked.&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: What&apos;s up?&gt;]&gt;# Django provides a rich database lookup API that&apos;s entirely driven by# keyword arguments.&gt;&gt;&gt; Question.objects.filter(id=1)&lt;QuerySet [&lt;Question: What&apos;s up?&gt;]&gt;&gt;&gt;&gt; Question.objects.filter(question_text__startswith=&apos;What&apos;)&lt;QuerySet [&lt;Question: What&apos;s up?&gt;]&gt;# Get the question that was published this year.&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; current_year = timezone.now().year&gt;&gt;&gt; Question.objects.get(pub_date__year=current_year)&lt;Question: What&apos;s up?&gt;# Request an ID that doesn&apos;t exist, this will raise an exception.&gt;&gt;&gt; Question.objects.get(id=2)Traceback (most recent call last): ...DoesNotExist: Question matching query does not exist.# Lookup by a primary key is the most common case, so Django provides a# shortcut for primary-key exact lookups.# The following is identical to Question.objects.get(id=1).&gt;&gt;&gt; Question.objects.get(pk=1)&lt;Question: What&apos;s up?&gt;# Make sure our custom method worked.&gt;&gt;&gt; q = Question.objects.get(pk=1)&gt;&gt;&gt; q.was_published_recently()True# Give the Question a couple of Choices. The create call constructs a new# Choice object, does the INSERT statement, adds the choice to the set# of available choices and returns the new Choice object. Django creates# a set to hold the &quot;other side&quot; of a ForeignKey relation# (e.g. a question&apos;s choice) which can be accessed via the API.&gt;&gt;&gt; q = Question.objects.get(pk=1)# Display any choices from the related object set -- none so far.&gt;&gt;&gt; q.choice_set.all()&lt;QuerySet []&gt;# Create three choices.&gt;&gt;&gt; q.choice_set.create(choice_text=&apos;Not much&apos;, votes=0)&lt;Choice: Not much&gt;&gt;&gt;&gt; q.choice_set.create(choice_text=&apos;The sky&apos;, votes=0)&lt;Choice: The sky&gt;&gt;&gt;&gt; c = q.choice_set.create(choice_text=&apos;Just hacking again&apos;, votes=0)# Choice objects have API access to their related Question objects.&gt;&gt;&gt; c.question&lt;Question: What&apos;s up?&gt;# And vice versa: Question objects get access to Choice objects.&gt;&gt;&gt; q.choice_set.all()&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;&gt;&gt;&gt; q.choice_set.count()3# The API automatically follows relationships as far as you need.# Use double underscores to separate relationships.# This works as many levels deep as you want; there&apos;s no limit.# Find all Choices for any question whose pub_date is in this year# (reusing the &apos;current_year&apos; variable we created above).&gt;&gt;&gt; Choice.objects.filter(question__pub_date__year=current_year)&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;# Let&apos;s delete one of the choices. Use delete() for that.&gt;&gt;&gt; c = q.choice_set.filter(choice_text__startswith=&apos;Just hacking&apos;)&gt;&gt;&gt; c.delete() 6.Django管理页面首先创建一个管理员python manage.py createsuperuser 接下来会让你输入用户名、邮箱、密码、验证密码 完成后启动项目进入http://127.0.0.1:8000/admin/ ，输入你刚刚设置的账户密码进去后，我们可以通过这个页面进行管理。如果需要管理，我们要告诉他管理什么东西：进入polls/admin 12345from django.contrib import adminfrom .models import Questionadmin.site.register(Question) 现在可以通过admin管理question的内容","path":"2019/04/11/Django2-0使用/","date":"04-11","excerpt":"","tags":[{"name":"Django","slug":"Django","permalink":"https://jijiking51.cn/tags/Django/"}],"preview":"http://img.jijiking51.cn/Django 2.0使用.jpg"},{"title":"Django2.0整合markdown编辑器","text":"测试成功环境：python：3.5.4os：Deepin 15.5Django：2.0IDE：pycharm 1.Django整合Ueditor（百度制作的编辑器）学习于博主： Code人生 请按照博主的教程一步一步走，其中下载的DjangoUeditor/DjangoUeditor中的代码导入模块有问题，请完善路径2.Django整合django-mdeditor1.安装django-mdeditorshell中运行1pip3 install django-mdeditor ##2.新建一个项目 ## 在项目的settings.py的INSTALLED_APPS中添加’mdeditor’, 添加媒体路径到你的设置中： 12MEDIA_ROOT = os.path.join(BASE_DIR, &apos;uploads&apos;)MEDIA_URL = &apos;/media/&apos; 在你的根目录下分别创建对应的文件夹 uploads/editor 将该设置添加到你的urls.py中： 1234567891011121314from django.conf.urls import url, includefrom django.conf.urls.static import staticfrom django.conf import settingsfrom django.contrib import adminfrom django.urls import pathurlpatterns = [ path(&apos;admin/&apos;,admin.site.urls), url(r&apos;mdeditor/&apos;, include(&apos;mdeditor.urls&apos;)),]if settings.DEBUG: # static files (images, css, javascript, etc.) urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 如果是按照教程的步骤新建的项目，请直接覆盖源代码即可 ##3.添加一个app ##shell在根目录中运行： 1python manage.py startapp Example 打开Example，在models.py中添加 123456from django.db import modelsfrom mdeditor.fields import MDTextFieldclass ExampleModel(models.Model): name = models.CharField(max_length=10) content = MDTextField() 在Example/admin.py中粘贴 123456from django.contrib import admin# Register your models here.from Example.models import ExampleModeladmin.site.register(ExampleModel) 再次回到项目中，在settings.py的INSTALLED_APPS中添加‘Example’, 然后我们运行引用model 12python manage.py makemigrationspython manage.py migrate 最后设置admin用户 1python manage.py createsuperuser 按照提示， 设置用户名，邮箱，密码之后就完成了 4.查看效果运行项目打开http://127.0.0.1:8000/admin/ 输入刚刚设置的账户和密码 点击Add添加你的第一篇文章","path":"2019/04/11/Django2-0整合markdown编辑器/","date":"04-11","excerpt":"","tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://jijiking51.cn/tags/Markdown/"},{"name":"Django","slug":"Django","permalink":"https://jijiking51.cn/tags/Django/"}],"preview":"http://img.jijiking51.cn/Django2.0整合markdown编辑器.jpg"},{"title":"JAVA_返回引用可变对象的访问器方法避免破坏封装性","text":"如果需要返回一个可变对象的引用， 应该首先对他进克隆（clone）。对象克隆是指存放在另一个位置上的对象副本。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Date;class b&#123; private Date day; public b()&#123; this.day = new Date(); &#125; public Date getDay()&#123; return this.day; &#125;&#125;class a&#123; private Date day ; public a()&#123; this.day = new Date(); &#125; public Date getDay()&#123; //使用clone方法 返回的是一个存放在另一个位置上的对象副本 return (Date)this.day.clone(); &#125;&#125;public class demo&#123; public static void main(String[] args) &#123; a obj = new a(); Date d = obj.getDay(); System.out.println(\"使用了clone避免封装被破坏的a类\"+obj.getDay().getYear()); d.setYear(2000); System.out.println(\"使用了clone避免封装被破坏的a类\"+obj.getDay().getYear()); b obj_B = new b(); Date d_bDate = obj_B.getDay(); System.out.println(\"没有使用了clone避免封装被破坏的b类\"+obj_B.getDay().getYear()); d_bDate.setYear(2000); System.out.println(\"没有使用了clone避免封装被破坏的b类\"+obj_B.getDay().getYear()); &#125;&#125;","path":"2019/04/11/JAVA-返回引用可变对象的访问器方法避免破坏封装性/","date":"04-11","excerpt":"","tags":[{"name":"基础","slug":"基础","permalink":"https://jijiking51.cn/tags/基础/"}],"preview":"http://img.jijiking51.cn/JAVA_返回引用可变对象的访问器方法避免破坏封装性.jpg"},{"title":"Java_如何交换两个对象","text":"java语言中，方法参数有一下几个注意点: 一个方法不能修改一个基本数据类型的参数（即数值型和布尔型） 一个方法可以改变一个对象参数的状态 一个方法不能让对象参数引用一个新的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103class A&#123; String name ; public A(String name)&#123; this.name = name; &#125; public A clone()&#123; return this; &#125;&#125;class WrapperA&#123; A a ; public WrapperA(A a)&#123; this.a = a; &#125;&#125;public class demo&#123; public static void main(String[] args) &#123; //1.验证第一条定义 int number1 = 100; int number2 = 200; swapNumber(number1, number2); //结果是 100 200 并没有改变基本类型 System.out.println(number1+\" \"+number2); //2.验证第二条定义 A testA = new A(\"testA1\"); change(testA); //结果是testA2 改变了引用类型 System.out.println(testA.name); //验证第三条定义 A a1 = new A(\"1\"); A a2 = new A(\"2\"); swapA(a1, a2); /*结果还是 1 2 并没有交换 一个方法并不能让对象参数引用一个新的对象。 原理： 当a1传入swapA时，复制了一个引用对象x，也就是swapA中的a1 swapA中将x指向了a2 但是a1 并没有改变 所以改变的仅仅是复制的引用，原来的引用并没有改变 */ System.out.println(a1.name+\" \"+a2.name); //如果想交换可以使用以下方法 WrapperA wa1 = new WrapperA(a1); WrapperA wa2 = new WrapperA(a2); swapWrapperA(wa1, wa2); a1 = wa1.a; a2 = wa2.a; //a1 和 a2 被改变 System.out.println(a1.name+\" \"+a2.name); &#125; //用于测试第一条定义 static void swapNumber(int a , int b)&#123; a += b; b = a - b; a = a - b; &#125; //用于测试第二条定义 static void change(A a)&#123; a.name = \"testA2\"; &#125; //用于测试第三条定义 static void swapA(A a1 , A a2)&#123; A a3 = a1.clone() ; a1 = a2.clone(); a2 = a3; System.out.println(a1.name); &#125; //交换方法 static void swapWrapperA(WrapperA a1,WrapperA a2)&#123; A a3 = a1.a; a1.a = a2.a; a2.a = a3; &#125;&#125;","path":"2019/04/11/Java-如何交换两个对象/","date":"04-11","excerpt":"","tags":[{"name":"基础","slug":"基础","permalink":"https://jijiking51.cn/tags/基础/"}],"preview":"http://img.jijiking51.cn/Java_如何交换两个对象.jpg"},{"title":"Nginx安装配置并使用keepalived实现高可用双机热备","text":"所用安装包也可以从此处下载 下载nginx 官网：https://nginx.org/（我的是1.8.1） 上传并解压nginx tar -zxvf nginx-1.8.1.tar.gz -C /usr/local/src 编译nginx #进入到nginx源码目录 cd /usr/local/src/nginx-1.8.1 #检查安装环境,并指定将来要安装的路径 ./configure –prefix=/usr/local/nginx #缺包报错 ./configure: error: C compiler cc is not found #使用YUM安装缺少的包 yum -y install gcc pcre-devel openssl openssl-devel（centos命令，如果是其他系统请自行更改） 编译安装 make &amp;&amp; make install 安装完后测试是否正常：/usr/loca/nginx/sbin/nginx查看端口是否有ngnix进程监听netstat -ntlp | grep 80如果启动nginx报错：nginx: [emerg] open() “/etc/nginx.conf” failed (2: no such file or directory) find / -name nginx.conf cp 查找到的nginx.conf位置 启动缺少nginx.conf位置 配置nginx 打开nginx.conf 修改nginx配置文件server { listen 80; server_name xxx.com; #nginx所在服务器的主机名#反向代理的配置location / { #拦截所有请求 root html;proxy_pass http://192.168.0.21:8080; #这里是代理走向的目标服务器：tomcat }} 12#重启nginxkill -HUP `cat /usr/local/nginx/logs/nginx.pid ` 动静分离 删除上面的server配置 按照上面的方法配置一下内容#动态资源 index.jsplocation ~ .*.(jsp|do|action)$ { proxy_pass http://192.168.0.2:8080;} #静态资源location ~ .*.(html|js|css|gif|jpg|jpeg|png)$ { expires 3d;} 负载均衡在http这个节下面配置一个叫upstream的，后面的名字可以随意取，但是要和location下的proxy_pass http://后的保持一致。 123456789101112http &#123; 是在http里面的, 已有http, 不是在server里,在server外面 upstream tomcats &#123; server shizhan02:8080 weight=1;#weight表示多少个 server shizhan03:8080 weight=1; server shizhan04:8080 weight=1; &#125;#卸载server里location ~ .*\\.(jsp|do|action) &#123; proxy_pass http://tomcats; #tomcats是后面的tomcat服务器组的逻辑组号 &#125;&#125; 利用keepalived实现高可靠（HA）HA(High Available), 高可用性集群，是保证业务连续性的有效解决方案，一般有两个或两个以上的节点，且分为活动节点及备用节点。 keepalive是一款可以实现高可靠的软件，通常部署在2台服务器上，分为一主一备。Keepalived可以对本机上的进程进行检测，一旦Master检测出某个进程出现问题，将自己切换成Backup状态，然后通知另外一个节点切换成Master状态。 与上面安装过程一样 12345678910111213下载keepalived官网:https://keepalived.org将keepalived解压到/usr/local/src目录下tar -zxvf keepalived-1.2.19.tar.gz -C /usr/local/src进入到/usr/local/src/keepalived-1.2.19目录cd /usr/local/src/keepalived-1.2.19开始configure./configure --prefix=/usr/local/keepalived#编译并安装make &amp;&amp; make install 修改/etc/keepalived/keepalived.conf 配置虚拟ip 两个节点必须是在同一内网,配置心跳检测 原理： Keepalived并不跟nginx耦合，它俩完全不是一家人 但是keepalived提供一个机制：让用户自定义一个shell脚本去检测用户自己的程序，返回状态给keepalived就可以了 #MASTER节点 12345678910111213141516171819202122232425 vrrp_script chk_health &#123; script \"/usr/local/keepalived/sbin/notify.sh\" interval 1 weight -2 &#125; vrrp_instance VI_1 &#123; state MASTER #指定A节点为主节点 备用节点上设置为BACKUP即可 interface eth0 #绑定虚拟IP的网络接口 virtual_router_id 51 #VRRP组名，两个节点的设置必须一样，以指明各个节点属于同一VRRP组 priority 100 #主节点的优先级（1-254之间），备用节点必须比主节点优先级低 advert_int 1 #组播信息发送间隔，两个节点设置必须一样 mcast_src_ip 192.168.88.200 #本地主机ip authentication &#123; #设置验证信息，两个节点必须一致 auth_type PASS auth_pass 1111 &#125; track_script &#123; chk_health &#125; virtual_ipaddress &#123; #指定虚拟IP, 两个节点设置必须一样 192.168.88.199 #如果两个nginx的ip分别是192.168.88.200,,...201，则此处的虚拟ip跟它俩同一个网段即可 &#125;&#125; #BACKUP节点 12345678910111213141516171819202122232425262728 vrrp_script chk_health &#123; script \"/usr/local/keepalived/sbin/notify.sh\" interval 1 weight -2&#125; vrrp_instance VI_1 &#123; state BACKUP interface eth0 virtual_router_id 51 mcast_src_ip 192.168.88.201 priority 99 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; track_script &#123; chk_health &#125; virtual_ipaddress &#123; 192.168.88.199/24 &#125; &#125; #使用的脚本 123456789#!/bin/shA=`ps -C nginx --no-header |wc -l` #检查是否有nginx运行if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx #启动nginx sleep 2 #休眠两秒 if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then #如果两秒后nginx没有运行 killall keepalived #关闭keepalived ，将虚拟ip让给BACKUP节点（必须关闭MASTER上的keepalived，BACKUP才能的到VIP） fifi 启动两台机器上的nginx和keepalived /usr/local/nginx/sbin/ngin service keepalived start 测试 将MASTER节点上的notify.sh脚本写错nginx启动路径（例如：/usr/local/nginx/sbin/nginxxxxxxx）， 让keepalived稍后无法启动nginx而自己关闭，这样可以测试是否两个节点可以相互替换。 关闭MASTER节点上的nginx 1/usr/local/nginx/sbin/nginx -s stop 查看虚拟ip占用情况，正确情况应该是MASTER上的虚拟ip消失，而BACKUP上出现你所配置的虚拟ip 1ip -a | grep eth0 在浏览器中打开你配置的虚拟ip ，进行多个测试， 无论是MASTER节点是否存活，只要BACKUP还存活都可以正常运行 如果测试中发现两个节点都出现了虚拟ip的，首先尝试关闭自己的防火墙servcie iptables stop 暂时关闭防火墙chkconfig iptables off 永久关闭防火墙","path":"2019/04/11/Nginx安装配置并使用keepalived实现高可用双机热备/","date":"04-11","excerpt":"","tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://jijiking51.cn/tags/踩坑/"},{"name":"配置","slug":"配置","permalink":"https://jijiking51.cn/tags/配置/"},{"name":"高可用","slug":"高可用","permalink":"https://jijiking51.cn/tags/高可用/"}],"preview":"http://img.jijiking51.cn/Nginx安装配置并使用keepalived实现高可用双机热备.jpg"},{"title":"ZooKeeper详解","text":"前言提到ZooKeeper，相信大家都不会陌生。Dubbo，Kafka,Hadoop等等项目里都能看到它的影子。但是你真的了解 ZooKeeper 吗？如果面试官让你给他讲讲 ZooKeeper 是个什么东西，你能回答到什么地步呢？ 我会用两个篇幅介绍ZooKeeper ，第一篇是概念性的认识，这篇你会得到 ZooKeeper 是什么，ZooKeeper 设计的目标，ZooKeeper 能做什么和ZooKeeper 基本的概念。第二篇我会从实战出发，安装ZooKeeper，写一些ZooKeeper 具体应用场景的代码实现。 一、ZooKeeper是什么ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 官网：http://zookeeper.apache.org/ 源码：https://github.com/apache/zookeeper 二、ZooKeeper 的由来下面这段内容摘自《从Paxos到Zookeeper 》 ，本文中很多的名词介绍也来自本书。 Zookeeper最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目),雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家RaghuRamakrishnan开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而Zookeeper 正好要用来进行分布式环境的协调一一于是，Zookeeper 的名字也就由此诞生了。 三、ZooKeeper的特性顺序一致性，从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中去。 原子性，所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事务，要么都没有应用。 单一视图，无论客户端连接的是哪个 Zookeeper 服务器，其看到的服务端数据模型都是一致的。 可靠性，一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会一直被保留，除非有另一个事务对其进行了变更。 实时性，Zookeeper 保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。 四、ZooKeeper的设计目标简单的数据结构Zookeeper 使得分布式程序能够通过一个共享的树形结构的名字空间来进行相互协调，即Zookeeper 服务器内存中的数据模型由一系列被称为ZNode的数据节点组成，Zookeeper 将全量的数据存储在内存中，以此来提高服务器吞吐、减少延迟的目的。 可以构建集群Zookeeper 集群通常由一组机器构成，组成 Zookeeper 集群的而每台机器都会在内存中维护当前服务器状态，并且每台机器之间都相互通信。 顺序访问对于来自客户端的每个更新请求，Zookeeper 都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序。 高性能Zookeeper 和Redis一样全量数据存储在内存中，100%读请求压测QPS 12-13W。 五、关于 ZooKeeper 的一些重要概念5.1 Zookeeper 集群：Zookeeper 是一个由多个 server 组成的集群,一个 leader，多个 follower。（这个不同于我们常见的Master/Slave模式）leader 为客户端服务器提供读写服务，除了leader外其他的机器只能提供读服务。每个 server 保存一份数据副本全数据一致，分布式读 follower，写由 leader 实施更新请求转发，由 leader 实施更新请求顺序进行，来自同一个 client 的更新请求按其发送顺序依次执行数据更新原子性，一次数据更新要么成功，要么失败。全局唯一数据视图，client 无论连接到哪个 server，数据视图都是一致的实时性，在一定事件范围内，client 能读到最新数据。 5.2 集群角色Leader：是整个 Zookeeper 集群工作机制中的核心 。Leader 作为整个 ZooKeeper 集群的主节点，负责响应所有对 ZooKeeper 状态变更的请求。主要工作： 事务请求的唯一调度和处理，保障集群处理事务的顺序性。集群内各服务器的调度者。Leader 选举是 Zookeeper 最重要的技术之一，也是保障分布式数据一致性的关键所在。我们以三台机器为例，在服务器集群初始化阶段，当有一台服务器Server1启动时候是无法完成选举的，当第二台机器 Server2 启动后两台机器能互相通信，每台机器都试图找到一个leader，于是便进入了 leader 选举流程. 每个 server 发出一个投票投票的最基本元素是（SID-服务器id,ZXID-事物id）接受来自各个服务器的投票处理投票优先检查 ZXID(数据越新ZXID越大),ZXID比较大的作为leader，ZXID一样的情况下比较SID统计投票这里有个过半的概念，大于集群机器数量的一半，即大于或等于（n/2+1）,我们这里的由三台，大于等于2即为达到“过半”的要求。这里也有引申到为什么 Zookeeper 集群推荐是单数。| 集群数量 | 至少正常运行数量 | 允许挂掉的数量 || ——– | —————————– | ————– || 2 | 2的半数为1，半数以上最少为2 | 0 || 3 | 3的半数为1.5，半数以上最少为2 | 1 || 4 | 4的半数为2，半数以上最少为3 | 1 || 5 | 5的半数为2.5，半数以上最少为3 | 2 || 6 | 6的半数为3，半数以上最少为4 | 2 | 通过以上可以发现，3台服务器和4台服务器都最多允许1台服务器挂掉，5台服务器和6台服务器都最多允许2台服务器挂掉,明显4台服务器成本高于3台服务器成本，6台服务器成本高于5服务器成本。这是由于半数以上投票通过决定的。 改变服务器状态 一旦确定了 leader，服务器就会更改自己的状态，且一半不会再发生变化，比如新机器加入集群、非 leader 挂掉一台。 Follower ：是 Zookeeper 集群状态的跟随者。他的逻辑就比较简单。除了响应本服务器上的读请求外，follower 还要处理leader 的提议，并在 leader 提交该提议时在本地也进行提交。另外需要注意的是，leader 和 follower 构成ZooKeeper 集群的法定人数，也就是说，只有他们才参与新 leader的选举、响应 leader 的提议。 Observer ：服务器充当一个观察者的角色。如果 ZooKeeper 集群的读取负载很高，或者客户端多到跨机房，可以设置一些 observer 服务器，以提高读取的吞吐量。Observer 和 Follower 比较相似，只有一些小区别：首先 observer 不属于法定人数，即不参加选举也不响应提议，也不参与写操作的“过半写成功”策略；其次是 observer 不需要将事务持久化到磁盘，一旦 observer 被重启，需要从 leader 重新同步整个名字空间。 5.3会话（Session）Session 指的是 ZooKeeper 服务器与客户端会话。在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。 Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。 5.3.1 会话（Session）在Zookeeper客户端与服务端成功完成连接创建后，就创建了一个会话，Zookeeper会话在整个运行期间的生命周期中，会在不同的会话状态中之间进行切换，这些状态可以分为CONNECTING、CONNECTED、RECONNECTING、RECONNECTED、CLOSE等。 一旦客户端开始创建Zookeeper对象，那么客户端状态就会变成CONNECTING状态，同时客户端开始尝试连接服务端，连接成功后，客户端状态变为CONNECTED，通常情况下，由于断网或其他原因，客户端与服务端之间会出现断开情况，一旦碰到这种情况，Zookeeper客户端会自动进行重连服务，同时客户端状态再次变成CONNCTING，直到重新连上服务端后，状态又变为CONNECTED，在通常情况下，客户端的状态总是介于CONNECTING 和CONNECTED 之间。但是，如果出现诸如会话超时、权限检查或是客户端主动退出程序等情况，客户端的状态就会直接变更为CLOSE状态。 5.3.2 会话创建Session是Zookeeper中的会话实体，代表了一个客户端会话，其包含了如下四个属性 sessionID。会话ID，唯一标识一个会话，每次客户端创建新的会话时，Zookeeper都会为其分配一个全局唯一的sessionID。 TimeOut。会话超时时间，客户端在构造Zookeeper实例时，会配置sessionTimeout参数用于指定会话的超时时间，Zookeeper客户端向服务端发送这个超时时间后，服务端会根据自己的超时时间限制最终确定会话的超时时间。 TickTime。下次会话超时时间点，为了便于Zookeeper对会话实行”分桶策略”管理，同时为了高效低耗地实现会话的超时检查与清理，Zookeeper会为每个会话标记一个下次会话超时时间点，其值大致等于当前时间加上TimeOut。 isClosing。标记一个会话是否已经被关闭，当服务端检测到会话已经超时失效时，会将该会话的isClosing标记为”已关闭”，这样就能确保不再处理来自该会话的心情求了。Zookeeper为了保证请求会话的全局唯一性，在SessionTracker初始化时，调用initializeNextSession方法生成一个sessionID，之后在Zookeeper运行过程中，会在该sessionID的基础上为每个会话进行分配，初始化算法如下 1234567public static long initializeNextSession(long id) &#123; long nextSid = 0; // 无符号右移8位使为了避免左移24后，再右移8位出现负数而无法通过高8位确定sid值 nextSid = (System.currentTimeMillis() &lt;&lt; 24) &gt;&gt;&gt; 8; nextSid = nextSid | (id &lt;&lt; 56); return nextSid;&#125; 5.3.3 会话管理Zookeeper的会话管理主要是通过SessionTracker来负责，其采用了分桶策略（将类似的会话放在同一区块中进行管理）进行管理，以便Zookeeper对会话进行不同区块的隔离处理以及同一区块的统一处理。 5.4 数据节点 Znode在Zookeeper中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。 5.4.1 节点类型在Zookeeper中，node可以分为持久节点和临时节点和顺序节点三大类。可以通过组合生成如下四种类型节点 PERSISTENT持久节点,节点创建后便一直存在于Zookeeper服务器上，直到有删除操作来主动清楚该节点。 PERSISTENT_SEQUENTIAL持久顺序节点,相比持久节点，其新增了顺序特性，每个父节点都会为它的第一级子节点维护一份顺序，用于记录每个子节点创建的先后顺序。在创建节点时，会自动添加一个数字后缀，作为新的节点名，该数字后缀的上限是整形的最大值。3.EPEMERAL临时节点，临时节点的生命周期与客户端会话绑定，客户端失效，节点会被自动清理。同时，Zookeeper规定不能基于临时节点来创建子节点，即临时节点只能作为叶子节点。4.EPEMERAL_SEQUENTIAL临时顺序节点,在临时节点的基础添加了顺序特性。 5.5 版本——保证分布式数据原子性操作每个数据节点都具有三种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。 version– 当前数据节点数据内容的版本号cversion– 当前数据子节点的版本号aversion– 当前数据节点ACL变更版本号 上述各版本号都是表示修改次数，如version为1表示对数据节点的内容变更了一次。即使前后两次变更并没有改变数据内容，version的值仍然会改变。version可以用于写入验证，类似于CAS。 5.6watcher事件监听器ZooKeeper允许用户在指定节点上注册一些Watcher，当数据节点发生变化的时候，ZooKeeper服务器会把这个变化的通知发送给感兴趣的客户端 5.7 ACL 权限控制——保障数据的安全ACL是Access Control Lists 的简写， ZooKeeper采用ACL策略来进行权限控制，有以下权限：CREATE:创建子节点的权限READ:获取节点数据和子节点列表的权限WRITE:更新节点数据的权限DELETE:删除子节点的权限ADMIN:设置节点ACL的权限 5.8 Paxos算法Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。（其他算法有二阶段提交、三阶段提交等）篇幅较长 可以参考https://www.cnblogs.com/linbingdong/p/6253479.html 六、ZooKeeper 可以做什么？ 分布式服务注册与订阅 在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，比较典型的服务注册与订阅，代表：dubbo。分布式配置中心发布与订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者获取数据，实现配置信息的集中式管理和动态更新。代表：百度的disconf。github：https://github.com/knightliao/disconf 命名服务在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务地址，进程对象等等——这些我们都可以统称他们为名字（Name）。其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。 分布式锁分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序。所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。控制时序，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已绊预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序 Master选举 负载均衡","path":"2019/04/11/ZooKeeper详解/","date":"04-11","excerpt":"","tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://jijiking51.cn/tags/zookeeper/"}],"preview":"http://img.jijiking51.cn/ZooKeeper详解.jpg"},{"title":"MybatisGenerator逆向工程","text":"项目介绍：http://www.mybatis.org/generator/XML中的标签意思：http://www.mybatis.org/generator/quickstart.htmlXML示例文件：http://www.mybatis.org/generator/configreference/xmlconfig.html启动方式：http://www.mybatis.org/generator/running/running.html本文采用_From another Java program with an XML configuration的方式启动&nbsp;&nbsp; 详细使用看注释 eBg.xml配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt;&lt;!-- 设置连接的jar包 --&gt; &lt;classPathEntry location=\"mysql-connector-java-5.1.46-bin.jar\" /&gt; &lt;!-- targetRuntime：用来设置生成的类型 MyBatis3:标准类型，包含了动态查询的Example MyBatis3Simple：简单的增删查改--&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;!-- jdbcConnection:指定如何链接到目标数据库 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true\" userId=\"root\" password=\"123456\"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator:指定javaBean的生成策略， targetPackage=\"test.model\"：目标包名 targetProject=\"\\MBGTestProject\\src\"：目标工程 生成的是对象.java文件 --&gt; &lt;javaModelGenerator targetPackage=\"cn.jijiking51.mybatis.bean\" targetProject=\"src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator:sql 映射生成策略 生成的是：生成的是对象Mapper.xml文件 eclipse中 只要都是代码文件夹， 包路径相同的话编译的时候会合并到bin中，所以选择的文件路径可以不是conf，但是包名一定要相同 idea中， Mapper.xml 和 Mapper.java 一定要相同路径文件夹 ******这个是否需要取决于下面type选择的模式，只有XMLMAPPER模式需要这个****** --&gt; &lt;sqlMapGenerator targetPackage=\"cn.jijiking51.mybatis.dao\" targetProject=\"conf\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator：指定mapper接口所在的文件位置 生成的是：生成的是对象Mapper.java文件 注意生成xml的文件位置 type=\"ANNOTATEDMAPPER\",生成Java Model 和基于注解的Mapper对象 type=\"MIXEDMAPPER\",生成基于注解的Java Model 和相应的Mapper对象 type=\"XMLMAPPER\",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"cn.jijiking51.mybatis.dao\" targetProject=\"src\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- table：制定要逆向分析哪些表:根据表生成javaBean ， table 表名， domainObjectNam --&gt; &lt;table tableName=\"employee\" domainObjectName=\"Employee\"&gt;&lt;/table&gt; &lt;table tableName=\"user\" domainObjectName=\"User\"&gt;&lt;/table&gt; &lt;table tableName=\"tb_class\" domainObjectName=\"Class\"&gt;&lt;/table&gt; &lt;table tableName=\"tb_head_teacher\" domainObjectName=\"Teacher\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 启动：注意要修改成自己的xml文件 12345678910111213@Test public void testEbg() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //唯一要修改的地方就是引入这个xml配置文件 File configFile = new File(\"eBg.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;","path":"2019/04/11/MybatisGenerator逆向工程/","date":"04-11","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://jijiking51.cn/tags/Mybatis/"},{"name":"开发","slug":"开发","permalink":"https://jijiking51.cn/tags/开发/"}],"preview":"http://img.jijiking51.cn/MybatisGenerator逆向工程.jpg"},{"title":"ubuntu18.04安装Anaconda3+tensorflow-gpu1.8.0+cuda9.1+cudnn7.05","text":"参考测试代码来源：https://vimsky.com/article/3872.html18.04图形界面开启与关闭https://blog.csdn.net/happy_lucky52/article/details/82626901ubuntu18.04安装cuda+cudnnhttps://blog.csdn.net/u010801439/article/details/80483036 前提 下载Anaconda下载链接下载3.7 下载cuda下载地址选择9.1版本对对照图片选择，下载列表对应的选择第一个Download为cuda9.1 ，下面的还有三个（有一个没有截出来）为补丁，全部下载 下载cudnn下载链接选择Download cuDNN选择后如果没有账号请创建账号，如果有账号请登录，然后勾选用户协议选择存档的cuDNN版本下载对应的文件 现在我们手里有123456789###anaconda安装文件Anaconda3-2018.12-Linux-x86_64.sh###cuda安装文件以及补丁cuda_9.1.85_387.26_linux.runcuda_9.1.85.1_linux.runcuda_9.1.85.2_linux.runcuda_9.1.85.3_linux.run###cudnn文件cudnn-9.1-linux-x64-v7.tgz 如果文件少了请检查是否缺少步骤 ！！！！！！！！！接下来请关闭图形界面！！！！！！！！！18.04用户请执行以下命令，其他版本用户请自行搜索关闭ubuntu图形界面12sudo systemctl set-default multi-user.targetsudo reboot 安装完毕后用以下命令恢复12sudo systemctl set-default graphical.targetsudo reboot 卸载当前系统安装的NVIDIA驱动 1sudo apt remove --purge nvidia* 安装NVIDIA驱动 查看系统推荐驱动 123456789101112ubuntu-drivers devices###得到的结果== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==modalias : pci:v000010DEd0000139Bsv00001558sd00000152bc03sc00i00vendor : NVIDIA Corporationmodel : GM107M [GeForce GTX 960M]driver : nvidia-driver-396 - third-party freedriver : nvidia-driver-410 - third-party freedriver : nvidia-driver-390 - third-party freedriver : nvidia-driver-415 - third-party free recommendeddriver : xserver-xorg-video-nouveau - distro free builtin 安装推荐的驱动 123456###1. 添加NVIDIA源，建议添加源后再次运行上面的命令，可以查看更加完整的驱动推荐sudo add-apt-repository ppa:graphics-drivers/ppa###2. 更新源sudo apt-get update###3. 安装上面推荐的驱动，具体选择根据上面的推荐和tensorflow-gpu的实际需求，对应版本表见下方sudo apt-get install nvidia-*** tensorflow-gpu版本对应关系 安装cuda9.1 ubuntu18.04是7.0的gcc和g++，而cuda需要的是4.8 所以我们进行降级处理 123456789101112###1. 安装gcc和g++ 4.8版本sudo apt-get install gcc-4.8sudo apt-get install g++-4.8###2.更改引用 ###1. 进入/usr/bin cd /usr/bin ###2. 备份 sudo mv gcc gcc.bak sudo mv g++ g++.bak ###3. 重新创建软链 sudo ln -s gcc-4.8 gcc sudo ln -s g++-4.8 g++ 安装cuda_9.1.85_387.26_linux.run 12345sudo sh cuda_9.1.85_387.26_linux.run###按照它的提示选择输入 accept | y###因为我们更改已经安装了NVIDIA驱动，所以在是否安装驱动的选项时选择no，其他的选项全部选择yes###安装完成后会提示nvidia-driver没有安装，其他的安装完成###waring警告是告诉你如何安装上它的nvidia驱动 安装补丁 123sudo sh cuda_9.1.85.1_linux.runsudo sh cuda_9.1.85.2_linux.run sudo sh cuda_9.1.85.3_linux.run 添加环境变量 12345###cuda-x.x 请按照自己安装的版本实际环境更改echo &apos;export PATH=/usr/local/cuda-x.x/bin:$PATH&apos; &gt;&gt; ~/.bashrcecho &apos;export LD_LIBRARY_PATH=/usr/local/cuda-x.x/lib64:$LD_LIBRARY_PATH&apos; &gt;&gt; ~/.bashrc###更新配置source ~/.bashrc 安装cudnn7.05 解压cudnn-9.1-linux-x64-v7.tgz 1tar -zxvf cudnn-9.1-linux-x64-v7.tgz 复制到cuda的目录中 1234sudo cp cuda/include/cudnn.h /usr/local/cuda/include/ sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/ sudo chmod a+r /usr/local/cuda/include/cudnn.h sudo chmod a+r /usr/local/cuda/lib64/libcudnn* 安装anaconda 运行安装脚本 1234sh Anaconda3-2018.12-Linux-x86_64.sh###注意事项######除了最后问你是否安装vscode可以选择no，其他的请选择yes，否则请自行添加环境变量source ~/.bashrc 添加清华源 123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 创建一个python环境 12conda create -n tensorflow python=3.6conda activate tensorflow 安装tensorflow-gpu，版本请更具需要修改 1conda install -n tensorflow tensorflow-gpu==1.8.0 测试是否安装成功请先运行上面的恢复图形界面代码随后将这段代码粘贴到一个py文件中，使用刚刚创建的python环境运行 12345678import tensorflow as tfwith tf.device(&apos;/gpu:0&apos;): a = tf.constant([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], shape=[2, 3], name=&apos;a&apos;) b = tf.constant([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], shape=[3, 2], name=&apos;b&apos;) c = tf.matmul(a, b)with tf.Session() as sess: print (sess.run(c)) 如果安装成功会在最后显示这个结果12[[22. 28.] [49. 64.]] ​","path":"2019/04/11/ubuntu18-04安装Anaconda3-tensorflow-gpu1-8-0-cuda9-1-cudnn7-05/","date":"04-11","excerpt":"","tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://jijiking51.cn/tags/踩坑/"},{"name":"配置","slug":"配置","permalink":"https://jijiking51.cn/tags/配置/"}],"preview":"http://img.jijiking51.cn/ubuntu18.04安装Anaconda3+tensorflow-gpu1.8.0+cuda9.1+cudnn7.05.jpg"},{"title":"Mysql导入和导出Sql文件","text":"window下1.导出整个数据库mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名mysqldump -u dbuser -p dbname &gt; dbname.sql 2.导出一个表mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名mysqldump -u dbuser -p dbname users&gt; dbname_users.sql 3.导出一个数据库结构mysqldump -u dbuser -p -d –add-drop-table dbname &gt;d:/dbname_db.sql-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 4.导入数据库常用source 命令进入mysql数据库控制台，如mysql -u root -pmysql&gt;use 数据库然后使用source命令，后面参数为脚本文件(如这里用到的.sql)mysql&gt;source d:/dbname.sql 导入数据到数据库 mysql -uroot -D数据库名 导入数据到数据库中得某个表 mysql -uroot -D数据库名 表名 mysqldump 命令没找到请将目录切换到mysql的安装目录下的bin目录 linux下一、导出数据库用mysqldump命令（注意mysql的安装路径，即此命令的路径）：1、导出数据和表结构：mysqldump -u用户名 -p密码 数据库名 &gt; 数据库名.sql #/usr/local/mysql/bin/ mysqldump -uroot -p abc &gt; abc.sql敲回车后会提示输入密码 2、只导出表结构mysqldump -u用户名 -p密码 -d 数据库名 &gt; 数据库名.sql #/usr/local/mysql/bin/ mysqldump -uroot -p -d abc &gt; abc.sql 注：/usr/local/mysql/bin/ —&gt; mysql的data目录 二、导入数据库1、首先建空数据库mysql&gt;create database abc; 2、导入数据库方法一：（1）选择数据库mysql&gt;use abc;（2）设置数据库编码mysql&gt;set names utf8;（3）导入数据（注意sql文件的路径）mysql&gt;source /home/abc/abc.sql; 方法二：mysql -u用户名 -p密码 数据库名 &lt; 数据库名.sql #mysql -uabc_f -p abc &lt; abc.sql","path":"2019/04/11/Mysql导入和导出Sql文件/","date":"04-11","excerpt":"","tags":[{"name":"备份","slug":"备份","permalink":"https://jijiking51.cn/tags/备份/"}],"preview":"http://img.jijiking51.cn/Mysql导入和导出Sql文件.jpg"},{"title":"eclipse开发Hadoop时异常org.apache.hadoop.security.AccessControlException:","text":"问题原因1org.apache.hadoop.security.AccessControlException: Permission denied: user=min, access=WRITE, inode=&quot;/access_log_copy&quot;:mini:supergroup:-rw-r--r-- 我们可以看到user=min，这是我们当前运行系统的用户名，而这里期望值是Hadoop上面的用户名 解决方法所以有一下几种解决方法： 在JVM变量里面添加HADOOP_USER_NAME，例： 1-DHADOOP_USER_NAME=xxx 这里的xxx是Hadoop上面的用户名eclipse配置如下： 2. 将当前系统的帐号修改为Hadoop上运行的用户名 3. 在构造客户端fs对象时，通过对象传递进去 12345678910/** * 依赖的包名 * import java.net.URI; * import java.net.URISyntaxException; * import org.apache.hadoop.conf.Configuration; * import org.apache.hadoop.fs.FileSystem; */Configuration conf = new Configuration(); conf.set(\"fs.defaultFS\", \"hdfs://192.168.88.137:9000\"); fs = FileSystem.get(new URI(\"hdfs://192.168.88.137:9000\"),conf,\"mini\"); 推荐第一、三种","path":"2019/04/11/eclipse开发Hadoop时异常org-apache-hadoop-security-AccessControlException/","date":"04-11","excerpt":"","tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://jijiking51.cn/tags/踩坑/"},{"name":"eclipse","slug":"eclipse","permalink":"https://jijiking51.cn/tags/eclipse/"}],"preview":"http://img.jijiking51.cn/eclipse开发Hadoop时异常.jpg"},{"title":"eclipse设置自动补全并取消空格代码补全","text":"在网上找了很久但是都不尽人意，发现此篇文章，成功修改，借鉴一下，重要的不是修改那个文件，对于新版的eclipse关键是找到文件，如果你的没有，就去那个网址下一个吧 设置代码提示 打开 Eclipse 依次选择 Window -&gt; Perferences -&gt; Java -&gt; Editor -&gt; Content Assist，Auto activation triggers for Java：设置框中默认是”.” 现在将它改为： .abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_ 有老版本的Eclipse不支持定义这么多触发器，可以通过修改配置文件实现，网上资料很多。 然后你就会发现Eclipse可以使用更智能的代码提示了。但是现在有一个比较大的问题是，Eclipse智能过头了，它总想帮我们完成一些我们不想要的代码补完。比如按“=”和空格以后就会自动补完代码，这对很多人真的不能忍。 幸好Eclipse是开源软件，解决办法是直接修改代码提示功能的源代码，以完成我们需要的功能。 首先打开window-&gt;show view，选择Plug-ins，再找到org.eclipse.jface.text，右键单击，选择import as－&gt; Source Project，导入完成后，在你的workspace就可以看到这个project了。如果没有src这个文件夹，说明你使用的版本中没有带源代码，我正好也是这种情况。 源代码可以去这个地址下载（找了我好久好久） http://archive.eclipse.org/eclipse/downloads/ 在页面上选择你Eclipse版本的连接（我使用的是4.4.2），然后在新页面中下载eclipse-SDK-(***).zip，根据自己的需要选择合适的版本下载，大概200M左右。下载完成以后解压缩，在.\\eclipse\\plugins\\文件夹下找到 org.eclipse.jface.text.source_3.9.2.v20141003-1326.jar （这是对应我使用的Eclipse版本的文件，实际请根据你自己的版本进行选择），将这个文件复制到你自己的Eclipse安装目录下的.\\eclipse\\plugins\\文件夹下，然后重新启动Eclipse。重复上面的操作导入(import)org.eclipse.jface.text，此时就能够看到src文件夹了。 技术分享 在src文件夹下org.eclipse.jface.text.contentassist.CompletionProposalPopup#verifyKey()”函数中有一段代码: if(contains(triggers, key)){…} 将这段代码改为 if(key!=0x20&amp;&amp; key!=‘=‘&amp;&amp; key!=‘;‘&amp;&amp; contains(triggers, key)){…} 还有把这段代码之上的代码 case‘\\t‘:e.doit=false;fProposalShell.setFocus();returnfalse; 修改为 case‘\\t‘:e.doit=false;insertSelectedProposalWithMask(e.stateMask);break; 经过上述操作，这个辅助输入插件已经排除了空格与“=”的选中功能，增加了TAB键的选中功能。最后就是导出修改后的插件，右键点击你的workspace里的工程，选择Export－&gt;Deployable plugins and fragments，点击Next，选择Destination选项卡，选择Directory，选择一个要保存插件的目录，然后Finish。然后就会在你所选的目录下产生一个新的plugins目录，里面有一个jar文件，用它替换掉eclipse/plugins里面的org.eclipse.jface.text，记得覆盖前对原文件进行备份。然后重新启动Eclipse","path":"2019/04/11/eclipse设置自动补全并取消空格代码补全/","date":"04-11","excerpt":"","tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://jijiking51.cn/tags/踩坑/"},{"name":"eclipse","slug":"eclipse","permalink":"https://jijiking51.cn/tags/eclipse/"}],"preview":"http://img.jijiking51.cn/eclipse设置自动补全并取消空格代码补全.jpg"},{"title":"ElasticSearch使用记录","text":"IK分词器建立类型请求的链接: 127.0.0.1:9200/noob/goods/_mapping请求类型: PUT请求数据:123456789101112131415161718192021222324&#123; \"properties\": &#123; \"id\": &#123; \"type\": \"long\" //long类型 &#125;, \"title\": &#123; \"type\": \"text\", // 字符类型 \"analyzer\": \"ik_max_word\", // 使用ik分词器 ik_max_word : 最细粒度 ik_smart : 最粗粒度 \"search_analyzer\": \"ik_max_word\" &#125;, \"type\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125;, \"goodsId\":&#123; \"type\": \"long\" &#125; &#125; &#125; 通过查询删除数据使用查找的方式,将查找的内容全部删除请求链接: 127.0.0.1:9200/noob/goods/_delete_by_query请求类型: POST请求数据:1234567&#123; \"query\": &#123; \"match\": &#123; \"goodsId\": \"47959547\" &#125; &#125;&#125;","path":"2019/04/11/ElasticSearch使用记录/","date":"04-11","excerpt":"","tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://jijiking51.cn/tags/踩坑/"},{"name":"配置","slug":"配置","permalink":"https://jijiking51.cn/tags/配置/"}],"preview":"http://img.jijiking51.cn/ElasticSearch使用记录.jpg"},{"title":"Java面试_操作系统","text":"线程与进程线程与进程理论 进程和线程以及他们的区别 进程：一个程序在一个数据集上的一次运行过程。系统资源分配的单位。 一个程序在不同数据集合上运行或一个程序在同样数据集上的多次运行都是不同的进程。 进程是独立的，有自己的内存空间和上下文环境，无法获取其他进程的存储空间。同一进程的两段代码不能同时执行，除非引入线程。 线程：进程的一个实体，是被系统独立调度和执行的基本单位，CPU使用的基本单位。 同一进程的线程可以共享同一内存空间。线程是属于进程的，当进程退出时该进程所产生的线程都会被强制退出并清除。线程占用的资源少于进程占用的资源 进程和线程都可以有优先级 进程在内存中的结构 代码区：存放CPU执行的机器指令，代码区是可共享，并且是只读的 数据段：全局变量、静态变量、常量（编译后知道大小）（未初始化的在一个区域(BBS区)，初始化的在相邻区域(数据区)） 全局变量：定义在函数外面，其他文件也能使用（external linkage） 静态变量：static 关键字修饰的变量： 函数外定义：全局变量，只在当前文件中可见（ internal linkage） 函数内定义：全局变量，只在此函数内可见 （C++）类中定义：全局变量，只在此类中可见 栈区：由编译器自动分配释放，存放函数的参数值、返回值和局部变量，在程序运行过程中实时分配和释放，栈区由操作系统自动管理，无须程序员手动管理 堆区：堆是由malloc()函数分配的内存块，使用free()函数来释放内存，堆的申请释放工作由程序员控制，容易产生内存泄漏 进程地址空间：内核地址空间+用户地址空间（代码段、数据段、堆、栈、共享库） 堆和栈的区别 栈：函数参数、返回地址、局部变量（运行入口知道大小） 编译器自动分配释放，存放函数的参数值，局部变量的值等。 申请后的响应：若栈的剩余空间大于申请空间，系统将为程序提供内存，否则提示栈溢出 大小限制：向低地址扩展，连续的内存区域，栈顶地址和栈最大容量是系统事先规定好的。如果申请的空间超过栈的剩余空间将栈溢出 申请效率：系统自动分配，速度快，程序员无法控制 存储的内容：函数调用时进栈顺序：主函数下一条指令的地址（函数调用语句的下一条可执行语句）、函数的各个参数（大多数c编译器中参数是从右往左入栈）、函数的局部变量。 调用结束的出栈顺序：局部变量、函数参数（从左到右）、栈顶指针指向最开始存的地址（即主函数的下一条指令） 堆：运行期间动态分配的内存空间（运行的时候才知道大小） 程序员自己分配释放，分配方式类似于链表 申请后的响应：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时会遍历该链表，寻找第一个空间大于所申请空间的堆结点，将该结点从空闲结点链表删除，分配该结点的空间给程序。会在这块内存空间中的首地址处记录本次分配的大小。 这样delete语句才能正确释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动将多余的那部分重新放入空闲链表中 大小限制：向高地址扩展，不连续的内存区域，用链表存储，遍历方向是由低地址向高地址。堆大小受限于计算机系统的有效虚拟内存。获得的空间更大更灵活 申请效率：用new分配，速度慢，容易产生内部碎片，使用方便 存储的内容：一般在堆的头部用一个字节放堆的大小 进程状态 创建（信息设置完但资源有限） 运行（占用cpu） 就绪（等待分配cpu） 等待（等待某个是啊金的发送） 终止（进程完成执行） 进程间的通信如何实现 通信的方式有：信号、信号量、消息队列、共享内存、管道、有名管道 管道(pipe)：半双工通信，数据单向流动；只能父子进程通信；速度慢 有名管道(FIFO)：任何进程都能通信；速度慢 信号量（semophore）：计数器，控制多个进程对共享资源的访问（多进程或线程的同步方法）；不能传递复杂消息 信号：用于通知接收进程某个事件已经发送 消息队列：消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递少、管道只能承载无格式字节流以及缓冲区大小受限的缺点；容量受限，第一次读的时候要考虑上一次没有读完数据的问题 需要消息复制，不需考虑同步问题，不适宜信息量大或操作频繁的场合 共享内存：映射一段能被其他进程访问的内存，由一个进程创建，可被多个进程访问，要保持同步。与信号量结合使用，用来达到进程间的同步及互斥，最快的IPC方式 不需要消息复制，信息量大，快捷，在任意数量的进程之间进行高效双向通信的机制。 套接字：可用于不同机器间的进程通信，由ip地址和端口号连接而成 进程调度 选择一个可用的进程到cpu上执行 进程进入系统，会被加入到作业队列（包括系统的所有进程）队列通常用链表实现，头结点指向的链表的第一个和最后一个pcb块的指针，每个pcb包括一个指向就绪队列的下一个pcb的指针域 运行—&gt;就绪：IO请求（–&gt;IO队列–&gt;IO结束）；时间片结束；创建一个子进程（等待子进程结束）；等待中断（中断发生） PCB： 进程标志 进程状态 程序计数器 寄存器 cpu调度信息：进程优先级、调度队列指针、其他调度参数 内存管理信息：基址寄存器 界限寄存器 页表/段表 记账信息：cpu时间、实际使用时间、时间界限、记账数据、作业或进程数量 I/O状态信息：分配给进程的IO设备列表、打开文件列表 线程状态 创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态 线程同步的方式 互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 处理机调度 先来先服务（FCFS，First-Come-First-Served）: 此算法的原则是按照作业到达后备作业队列（或进程进入就绪队列）的先后次序来选择作业（或进程）。 短作业优先（SJF,Shortest Process Next）：这种调度算法主要用于作业调度，它从作业后备队列中挑选所需运行时间（估计值）最短的作业进入主存运行。 时间片轮转调度算法（RR，Round-Robin）：当某个进程执行的时间片用完时，调度程序便停止该进程的执行，并将它送就绪队列的末尾，等待分配下一时间片再执行。然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片处理机执行时间。 高响应比优先（HRRN，Highest Response Ratio Next）: 按照高响应比（（已等待时间＋要求运行时间）/ 要求运行时间）优先的原则，在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行。 优先权(Priority)调度算法: 按照进程的优先权大小来调度，使高优先权进程得到优先处理的调度策略称为优先权调度算法。 多级队列调度算法：多队列调度是根据作业的性质和类型的不同，将就绪队列再分为若干个子队列，所有的作业（或进程）按其性质排入相应的队列中，而不同的就绪队列采用不同的调度算法。 说一说进程同步有哪几种机制 原子操作、信号量机制、自旋锁管程、会合、分布式系统 中断和轮询的特点 对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的，则加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此，程序轮询是一种效率较低的方式，在现代计算机系统中已很少应用。 程序中断通常简称中断，是指CPU在正常运行程序的过程中，由于预先安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为响应的服务程序去处理。 轮询——效率低，等待时间很长，CPU利用率不高。 中断——容易遗漏一些问题，CPU利用率高。 同步和互斥 同步是进程之间合作完成某功能，是进程之间的直接关系 互斥是多个进程公用某临界资源，是进程之间的间接关系 (互斥是不允许两个线程同时占有一个资源。同步是在互斥的基础上，再加了访问次序，比如生产消费者模式，需要先生成在消费。比如希尔排序，需要大的间隔度排序完，才能排步数小的） 经典同步问题， 生产消费者模式（Java多线程中也有） 线程&amp;锁 什么是死锁？ 死锁产生的条件？ 死锁的概念 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。 死锁产生的四个必要条件 互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止； 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有； 非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系 死锁的处理策略；鸵鸟策略、预防策略、避免策略、检测与恢复策略 死锁预防 打破互斥条件。即允许进程同时访问某些资源。但是有的资源是不允许被同时访问的。像打印机等等，这是有资源本身的属性所决定的。所以这种办法并无实用价值 打破不可抢占条件。即允许进程强行从占有者那里多去某些资源。就是说，当一个进程已占有了某些资源，他又申请新的资源，但不能立即被满足时，它必须释放所有占有的全部资源，然后再重新申请。它所释放的资源可以分配给其他进程。这就相当于该进程占有的资源被隐蔽地强占了，这种预防死锁的方法实现起来困难，会减低系统性能。 打破占有且申请条件。可以实行资源与预先分配策略。即进程在运行前一次性的向系统申请他所需要的全部资源，如果某个进程所需要的全部资源得不到满足，则不分配资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性的将所申请的资源全部分配给该进。由于运行的进程已占有了它所需要的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。但是这种策略也有如下缺点 在许多情况下，一个进程在执行之前不可能知道他所需要的全部资源。这是由于进程在执行时是动态的，不可预测的； 资源利用率低。无论所分配资源和使用到，一个进程只有在占有所需要的全部资源后才能执行。即使有些资源做后才被该进程用到一次，但该进程在生存期间却一直占有他们，造成长期占着不用的状况。这显然是一种极大的资源浪费 降低了进程的并发性。因为资源有限，又加上存在浪费，能分配到所需全部资源的进程个数就必然少了 打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源实现分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。这种策略与前面的策略相比，资源的利用率额系统吞吐量都有很大提高，但是也存在以下缺点： 限制了进程对资源的请求，同时给系统中所有资源合理编号也是件困难事，并增加了系统开销 为了遵循按编号申请的次序，暂不使用的资源也需要提前申请，从而增加了进程对资源的占用时间 线程如何避免死锁 固定加锁的顺序(针对锁顺序死锁) 开放调用(针对对象之间协作造成的死锁) 在一个锁内尽量不要调用其他带锁的方法 使用定时锁–&gt;tryLock() 如果等待获取锁时间超时，则抛出异常而不是一直等待！ 银行家算法 如何理解分布式锁 分布式锁，是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调它们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要不出来防止彼此干扰来保证一致性，在这种情况下，便需要使用分布式锁 临界区问题 【共享数据的互斥】 临界区：在该区中进程可能改变共同变量、更新一个表、写一个文件；没有两个进程能同时在临界区内执行。 123456do &#123; 【进入区】 // 请求允许进入其临界区 临界区 【退出区】 剩余区 &#125; while (true); eg. Peterson算法 123456789101112131415int turn; // 表示哪个进程可以进入临界区boolean flag[2]; // 表示哪个进程想要进入临界区 // Pi进程的结构------------------------------- do &#123; // 进入区 flag[i] = true; turn = j; while (flag[i] &amp;&amp; turn == j); // 临界区 flag[i] = false; // Pi最多在Pj进入临界区一次后就能进入---有限等待 // 剩余区&#125; while (true); 满足3个要求： 互斥（进程在临界区内执行，其他进程就不能在其临界区内执行） 前进（如果没有进程在其临界区执行且有进程需进入临界区，那么只有那些不在剩余区内执行的进程可参加选择，以确定谁能下一个进入临界区，且这种不能无线） 有限等待：从一个进程请求允许进入临界区到进入临界区为止，其他进程允许进入其临界区的次数有限 信号量 信号量S是一个整数型变量，信号量分为计数信号量（初始化为可用资源的数量）和二进制信号量（互斥锁）。 除了初始化外，只能通过两个标准【原子】操作：wait()和signal()来访问（这些操作被成为P测试和V增加） 123456789// 进程需要资源的时候 wait(S) &#123; while (S &lt;= 0); // 被阻塞----忙等待 S--; &#125; // 进程释放资源的时候 signal(S) &#123; S++; &#125; 这里定义的信号量【自旋锁】的主要缺点： 忙等待：当一个进程位于其临界区内时，其他试图进入临界区的进程需要在进入区连续第循环，浪费了cpu时钟 优点：进程在等待锁时不需要上下文切换，节省时间（如果锁占用时间短） 克服忙等：进程信号量不为正时不忙等二十阻塞自己，放入一个与信号量相关的等待队列中，状态为等待。 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？ 线程同步与阻塞没有一点关系 同步和异步关注的是消息通信机制(synchronous communication / asynchronous communication)。所谓同步，就是在发出一个调用时，在没有得到结果之前，这个调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。而异步则是相反，调用在发出之后这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立即得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。 阻塞和非阻塞关注的是程序在等待调用结果(消息、返回值)时的状态。阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立即得到结果之前，该调用不会阻塞当前线程 储存器管理 什么是缓冲区溢出？有什么危害？其原因是什么？ 缓冲区溢出是指计算机向缓冲区填充数据的时候超过了缓冲区本身的容量，溢出的数据覆盖在了合法数据上； 危害有以下两点： 程序崩溃，导致拒绝额服务 跳转并且执行一段恶意代码 造成缓冲区溢出的主要原因就是程序中没有检查用户输入的参数 分页和分段有什么区别 段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片） 页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。 两者的不同点： 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息； 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定； 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间； 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制； 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。 什么是虚拟内存 虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上 注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。 虚拟内存的应用与优点 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处： 在内存中可以保留多个进程，系统并发度提高 解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大 页面置换算法有哪些 最佳置换算法（Optimal）：即选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。（它是一种理想化的算法，性能最好，但在实际上难于实现）。 先进先出置换算法FIFO：该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。 最近最久未使用置换算法LRU（Least Recently Used）：该算法是选择最近最久未使用的页面予以淘汰，系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面。 Clock置换算法：也叫最近未用算法NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。当某页被访问时，其访问位置“1”。在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页，在循环队列中检查下一个页面，直到访问位为“0”的页面为止。由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法。 最少使用置换算法LFU：该算法选择最近时期使用最少的页面作为淘汰页。 颠簸/抖动 ​ 颠簸本质上是指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。 内存颠簸的解决策略包括： 如果是因为页面替换策略失误，可以修改替换算法来解决这个问题； 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量； 否则，还剩下两个办法：终止该进程或增加物理内存容量。 局部性原理 时间上的局部性：最近被访问的页在不久的将来还会被访问。 空间上的局部性：内存中被访问的页周围的页也很可能被访问。 CPU中的缓存和操作系统中的缓存分别是什么？ ​ 操作系统的缓存是指快表。在操作系统中，为提高系统的存取速度，在地址映射机制中增加一个小容量的联想寄存器，即快表，用来存放当前访问最频繁的少数活动页面的页号。当某用户需要存取数据时，根据数据所在的逻辑页号在快表中找到其对应的内存块号，再联系页内地址，形成物理地址。如果在快表中没有相应的逻辑页号，则地址映射仍可以通过内存中的页表进行，得到空闲块号后必须将该块号填入快表的空闲块中。如果快表中没有空闲块，则根据淘汰算法淘汰某一行，再填入新的页号和块号。快表查找内存块的物理地址消耗的时间大大降低了，使得系统效率得到了极大的提高。 ​ CPU中的缓存是指高速缓存。CPU的执行速度越来越快，系统架构越来越先进，而主存的结构和存取速度改进则较慢，因此，高速缓存技术将越来越重要。 高速缓冲存储器是位于CPU和内存之间的临时存储器，它的容量比内存小但交换速度快。在高速缓冲存储器中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的。当CPU调用大量数据时，就可避开内存直接从高速缓冲存储器中调用，从而加快读取速度。 存储器管理 存储器多层结构：寄存器，高速缓存，主存，磁盘程序装入与链接 分配方式：连续分配和离散分配 顺序动态分配： 首次适应 循环首次适应 最佳适应（找到刚好合适的） 最坏适应（每次找到最大的） 动态重定位分配： 紧凑法： 将碎片合并成大的空间， 但是影响系统效率 离散分配：分页，分段 分页：是物理大小，由系统决定，页面大小是固定的 分段： 大小是逻辑，用户决定的，段的大小是动态的 分页：页表存储在内存中，cpu先访问页表，再从页表中得到页号得到的物理地址，其中cpu访问两次内存，速度会明显变慢。通常会用高速缓存（“快表”），缓存当前访问到的页号对应的物理页面，如果没有命中，再去内存中访问页表。 分段： 方便编程，信息共享，信息保护，动态增长，动态链接 段页式：段表寄存器记录了段表的大小和起始地址，段表中的每条信息记录了段内页面的页表和起始地址，根据页表可以找到每个页面的位置。 段表=&gt;页表=&gt;最终页面 三次访问内存， 实际会设置高速寄存器，根据段号和页号，查看是否在缓存中命中 I/O管理一.操作系统与设备之间的IO简单来说（详细的请看《现代操作系统》），操作系统通过设备驱动程序访问IO设备。方式有： 轮询方式： CPU主动在各种设备中轮询检查状态，有数据就IO。 中断方式： 设备有数据的时候，发出中断，由CPU决定要不要响应中断，然后中断，去处理设备的IO。CPU不用经常轮询设备状态。被动接收中断就行。 DMA直接存储器访问方式： 如果1个字节的数据中断一次，传1KB的数据得中断1024次，太浪费CPU时间，于是有了DMA方式，CPU只需要把开头和结束的地址告诉DMA，中间由DMA完成数据IO。CPU从字节干预解放到数据块的干预。 通道控制方式： DMA方式只能控制一个设备的一块数据，多块数据还是要CPU干预多次。于是有了通道来控制IO，它比DMA更强大，能控制多块数据，多个设备的IO，更加解放了CPU参与IO过程。 二.操作系统与用户进程间的IO（进程中的线程才是CPU基本的执行/调度单元，下面用线程举例，用socket举例） 设备来的数据放在内核cache中，需要用户线程去内核cache中取数据，复制到自己进程的cache中。有5中读取数据方式： 阻塞： 用户线程调用某些系统函数去内核取数据，直到数据到达内核cache前，该线程处于阻塞状态，等待数据到达。 非阻塞 用户线程去取数据，不管内核cache有没有数据，都直接返回，可能拿到数据，也可能拿不到，不会使线程进入阻塞态。 IO多路复用 多路就是一个线程管理多路IO，线程还是被阻塞调用，其中一路或几路IO有数据了就返回。需要线程遍历全部IO，判断是哪个IO有数据。 例如 socket 的 select() 函数，线程调用 select() 进入阻塞态，任何一个IO有数据了，线程就退出阻塞态，获得机会继续执行。 信号驱动IO 给一个IO注册一个信号和信号触发的回调函数，一旦信号被触发，回调函数里读取数据。 例如给 socket 注册一个“可读”的信号，当数据来了，可读的时候，信号被触发，执行回调函数从内核cache复制数据到用户空间。 异步IO 异步IO中，操作系统完成了数据从内核到用户空间的拷贝后，以信号的方式通知用户线程可以下一步操作。省去了用户线程阻塞下来拷贝数据的过程。 IO管理假设一台服务器需要被1万个客户端连接。方法有： 单路： 最简单的一个线程管理一个客户端的socket IO，那么需要1万的线程，假设每个线程占内存3MB，需要300G内存，单台服务器没那么大的内存，并且操作系统最大线程数有限制，unix下一个进程好像是最多只能开 4096 个线程。 IO 多路复用： socket一旦多起来，单路IO 就扛不住了，需要一个线程管理多个 socket IO，下面都是在一个线程内的情况。 select 一个线程管理多个socket IO，调用 select() 进入阻塞态，任何一个IO有数据则返回，由于不知道是哪个 socket 有数据，需要遍历所有 socket fd 去判断，当1万个 socket 大部分都是有IO的时候，效率较高，如果只是那么几百个有IO，此方法效率较低。 epoll 和 kqueue epoll 是 linux 下的，kqueue 是 unix 下的。 由于 select 需要遍历全部的 socket fd，效率较低，于是有了 epoll, kqueue 方式，kqueue 管理多个IO，阻塞调用等待函数，当有一个或多个IO事件，kqueue 直接返回多个IO事件的 socket fd，不需要遍历全部 socket fd，效率较高。 假设一个 socket 连接的对象是 3 kb，8G的内存可以管理 280w 个连接。 select，epoll，kqueue 原理 已知的情况 内核中注册 socket 的 IO 中断处理的回掉函数，有 IO 了会回调该函数。 select： select 管理多个 socket，select 收到一个来自网卡 IO 中断就返回，不知道这个中断对应是哪个 socket fd 的。需要用户线程遍历判断。 epoll： epoll 收到一个 IO 中断，会去查找这个中断对应哪个 socket fd。 epoll 中建立一个红黑树（平衡二叉树的一种），红黑树查找很高效。 用户注册感兴趣的 socket 事件，就是把这个 socket fd 插入到红黑树中，用中断号做key，可以理解为（中断号，socket fd）的二元组。 用户移除事件就是，删除树上的某个节点。 然后收到一个IO中断，epoll 把网卡数据拷贝到内核cache，根据中断号在红黑树中查找对应的 fd，把 fd 加入到就绪链表中，准备返回给用户线程。用户直接得到就绪的 fd。 kqueue： 收到 socket IO 中断去哈希表中查找对应的 socket fd，再把它放到一个链表里，返回。 用户注册一个感兴趣的事件，就是往哈希表中添加一个 fd。 磁盘调度算法磁盘I/O传输时间Ta = Ts + 1/2r + b/rN Ts 寻道时间(时间最长 最需要优化) 1/2r 旋转延时的时间为磁盘旋转一周的时间的一半 b/rN b 传输的比特数 N 磁道上的比特数 r 磁盘转数 磁盘调度算法通过优化磁盘访问请求顺序来提高磁盘访问性能 寻道时间是磁道访问最耗时的部分 同时会有多个在同一磁盘上的I/O请求 随机处理磁盘访问请求的性能很差 先进先出算法(FIFO) 按顺序处理请求 公平对待所有进程 在有很多进程的情况下 接近随机调度的性能 磁盘访问序列 = 98,183,37,122,14,124,65,67初始磁头位置 53 最短服务时间优先(SSTF) 选择从磁臂当前位置需要移动最少的I/O请求 总是选择最短寻道时间 磁盘访问序列 = 98,183,37,122,14,124,65,67初始磁头位置 53 扫描算法(SCAN)磁臂在一个方向上移动 访问所有未完成的请求 直到磁臂到达该方向上最后的磁道 也称为电梯算法(elevator algorithm) 中间磁道的访问性能较好 两头的比较差 C-SCAN算法改进了这个缺点 磁盘访问序列 = 98,183,37,122,14,124,65,67初始磁头位置 53 循环扫描算法(C-SCAN)限制了仅在一个方向上扫描 当最后一个磁道也被访问过了以后 磁币返回到磁盘的另外一段再次进行 就算对头没有I/O请求也要走到头 浪费了 C-LOOK算法改进了这个缺点 C-LOOK算法磁臂先到达该方向上最后一个请求处 然后立即反转 而不是先到最后点路径上的所有请求 N步扫描(N-Step-SCAN)算法用于解决磁头粘着问题 磁头粘着(Arm Stickiness)现象 SSTF SCAN CSCAN等算法中 可能出现磁头停留在某处不动的情况 进程反复请求对某一磁道的I/O操作 将磁盘请求队列分成长度为N的子队列 按FIFO算法依次处理所有子队列 扫描算法处理每个队列 双队列扫描算法(FSCAN)FSCAN算法是N步扫描算法的简化 只将磁盘请求队列分成两个子队列 可以减少平均等待时间 把磁盘I/O请求分成两个队列 交替使用扫描算法处理一个队列 新生成的磁盘I/O请求放入另一队列中 所有的新请求都将被推迟到下一次扫描时处理 文件管理 文件系统种类 文件系统是操作系统用于明确磁盘或分区上的文件的方法和数据结构；即在磁盘上组织文件的方法。也指用于存储文件的磁盘或分区，或文件系统种类。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。文件系统由三部分组成：与文件管理有关软件、被管理文件以及实施文件管理所需数据结构。从系统角度来看，文件系统是对文件存储器空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。 FAT 常PC机使用的文件系统是FAT16。像基于MS-DOS，Win 95等系统都采用了FAT16文件系统。在Win 9X下，FAT16支持的分区最大为2GB。我们知道计算机将信息保存在硬盘上称为“簇”的区域内。使用的簇越小，保存信息的效率就越高。在FAT16的情况下，分区越大簇就相应的要大，存储效率就越低，势必造成存储空间的浪费。并且随着计算机硬件和应用的不断提高，FAT16文件系统已不能很好地适应系统的要求。在这种情况下，推出了增强的文件系统FAT32。同FAT16相比，FAT32主要具有以下特点： 1. 同FAT16相比FAT32最大的优点是可以支持的磁盘大小达到32G，但是不能支持小于512MB的分区。 基于FAT32的Win 2000可以支持分区最大为32GB；而基于 FAT16的Win 2000支持的分区最大为4GB。 2. 由于采用了更小的簇，FAT32文件系统可以更有效率地保存信息。如两个分区大小都为2GB，一个分区采用了FAT16文件系统，另一个分区采用了FAT32文件系统。采用FAT16的分区的簇大小为32KB，而FAT32分区的簇只有4KB的大小。这样FAT32就比FAT16的存储效率要高很多，通常情况下可以提高15%。 FAT32文件系统可以重新定位根目录和使用FAT的备份副本。另外FAT32分区的启动记录被包含在一个含有关键数据的结构中，减少了计算机系统崩溃的可能性。 NTFS NTFS文件系统是一个基于安全性的文件系统，是Windows NT所采用的独特的文件系统结构，它是建立在保护文件和目录数据基础上，同时照顾节省存储资源. 减少磁盘占用量的一种先进的文件系统。使用非常广泛的Windows NT 4.0采用的就是NTFS 4.0文件系统，相信它所带来的强大的系统安全性一定给广大用户留下了深刻的印象。Win 2000采用了更新版本的NTFS文件系统？？NTFS 5.0，它的推出使得用户不但可以像Win 9X那样方便快捷地操作和管理计算机，同时也可享受到NTFS所带来的系统安全性。 NTFS 5.0的特点主要体现在以下几个方面： 1. NTFS可以支持的分区（如果采用动态磁盘则称为卷）大小可以达到2TB。而Win 2000中的FAT32支持分区的大小最大为32GB。 2. NTFS是一个可恢复的文件系统。在NTFS分区上用户很少需要运行磁盘修复程序。NTFS通过使用标准的事物处理日志和恢复技术来保证分区的一致性。发生系统失败事件时，NTFS使用日志文件和检查点信息自动恢复文件系统的一致性。 3. NTFS支持对分区. 文件夹和文件的压缩。任何基于Windows的应用程序对NTFS分区上的压缩文件进行读写时不需要事先由其他程序进行解压缩，当对文件进行读取时，文件将自动进行解压缩；文件关闭或保存时会自动对文件进行压缩。 4. NTFS采用了更小的簇，可以更有效率地管理磁盘空间。在Win 2000的FAT32文件系统的情况下，分区大小在2GB～8GB时簇的大小为4KB；分区大小在8GB～16GB时簇的大小为8KB；分区大小在16GB～32GB时，簇的大小则达到了16KB。而Win 2000的NTFS文件系统，当分区的大小在2GB以下时，簇的大小都比相应的FAT32簇小；当分区的大小在2GB以上时（2GB～2TB），簇的大小都为4KB。相比之下，NTFS可以比FAT32更有效地管理磁盘空间，最大限度地避免了磁盘空间的浪费。 5. 在NTFS分区上，可以为共享资源. 文件夹以及文件设置访问许可权限。许可的设置包括两方面的内容：一是允许哪些组或用户对文件夹. 文件和共享资源进行访问；二是获得访问许可的组或用户可以进行什么级别的访问。访问许可权限的设置不但适用于本地计算机的用户，同样也应用于通过网络的共享文件夹对文件进行访问的网络用户。与FAT32文件系统下对文件夹或文件进行访问相比，安全性要高得多。另外，在采用NTFS格式的Win 2000中，应用审核策略可以对文件夹. 文件以及活动目录对象进行审核，审核结果记录在安全日志中，通过安全日志就可以查看哪些组或用户对文件夹. 文件或活动目录对象进行了什么级别的操作，从而发现系统可能面临的非法访问，通过采取相应的措施，将这种安全隐患减到最低。这些在FAT32文件系统下，是不能实现的。 6. 在Win 2000的NTFS文件系统下可以进行磁盘配额管理。磁盘配额就是管理员可以为用户所能使用的磁盘空间进行配额限制，每一用户只能使用最大配额范围内的磁盘空间。设置磁盘配额后，可以对每一个用户的磁盘使用情况进行跟踪和控制，通过监测可以标识出超过配额报警阈值和配额限制的用户，从而采取相应的措施。磁盘配额管理功能的提供，使得管理员可以方便合理地为用户分配存储资源，避免由于磁盘空间使用的失控可能造成的系统崩溃，提高了系统的安全性。 7. NTFS使用一个“变更”日志来跟踪记录文件所发生的变更。 Ext2 Ext2是 GNU/Linux 系统中标准的文件系统，其特点为存取文件的性能极好，对于中小型的文件更显示出优势，这主要得利于其簇快取层的优良设计。 其单一文件大小与文件系统本身的容量上限与文件系统本身的簇大小有关，在一般常见的 x86 电脑系统中，簇最大为 4KB，则单一文件大小上限为 2048GB，而文件系统的容量上限为 16384GB。 但由于目前核心 2.4 所能使用的单一分割区最大只有 2048GB，实际上能使用的文件系统容量最多也只有 2048GB。 至于Ext3文件系统，它属于一种日志文件系统，是对ext2系统的扩展。它兼容ext2，并且从ext2转换成ext3并不复杂。 Ext3 Ext3是一种日志式文件系统，是对ext2系统的扩展，它兼容ext2。日志式文件系统的优越性在于：由于文件系统都有快取层参与运作，如不使用时必须将文件系统卸下，以便将快取层的资料写回磁盘中。因此每当系统要关机时，必须将其所有的文件系统全部shutdown后才能进行关机。 如果在文件系统尚未shutdown前就关机 （如停电） 时，下次重开机后会造成文件系统的资料不一致，故这时必须做文件系统的重整工作，将不一致与错误的地方修复。然而，此一重整的工作是相当耗时的，特别是容量大的文件系统，而且也不能百分之百保证所有的资料都不会流失。 为了克服此问题，使用所谓‘日志式文件系统 （Journal File System） ’。此类文件系统最大的特色是，它会将整个磁盘的写入动作完整记录在磁盘的某个区域上，以便有需要时可以回溯追踪。 由于资料的写入动作包含许多的细节，像是改变文件标头资料. 搜寻磁盘可写入空间. 一个个写入资料区段等等，每一个细节进行到一半若被中断，就会造成文件系统的不一致，因而需要重整。 然而，在日志式文件系统中，由于详细纪录了每个细节，故当在某个过程中被中断时，系统可以根据这些记录直接回溯并重整被中断的部分，而不必花时间去检查其他的部分，故重整的工作速度相当快，几乎不需要花时间。 Ext4 Linux kernel 自 2.6.28 开始正式支持新的文件系统 Ext4。Ext4 是 Ext3 的改进版，修改了 Ext3 中部分重要的数据结构，而不仅仅像 Ext3 对 Ext2 那样，只是增加了一个日志功能而已。Ext4 可以提供更佳的性能和可靠性，还有更为丰富的功能： 1. 与 Ext3 兼容。执行若干条命令，就能从 Ext3 在线迁移到 Ext4，而无须重新格式化磁盘或重新安装系统。原有 Ext3 数据结构照样保留，Ext4 作用于新数据，当然，整个文件系统因此也就获得了 Ext4 所支持的更大容量。 更大的文件系统和更大的文件。较之 Ext3 目前所支持的最大 16TB 文件系统和最大 2TB 文件，Ext4 分别支持 1EB（1，048，576TB， 1EB=1024PB， 1PB=1024TB）的文件系统，以及 16TB 的文件。 无限数量的子目录。Ext3 目前只支持 32，000 个子目录，而 Ext4 支持无限数量的子目录。 Extents。Ext3 采用间接块映射，当操作大文件时，效率极其低下。比如一个 100MB 大小的文件，在 Ext3 中要建立 25，600 个数据块（每个数据块大小为 4KB）的映射表。而 Ext4 引入了现代文件系统中流行的 extents 概念，每个 extent 为一组连续的数据块，上述文件则表示为“该文件数据保存在接下来的 25，600 个数据块中”，提高了不少效率。 多块分配。当写入数据到 Ext3 文件系统中时，Ext3 的数据块分配器每次只能分配一个 4KB 的块，写一个 100MB 文件就要调用 25，600 次数据块分配器，而 Ext4 的多块分配器“multiblock allocator”（mballoc） 支持一次调用分配多个数据块。 延迟分配。Ext3 的数据块分配策略是尽快分配，而 Ext4 和其它现代文件操作系统的策略是尽可能地延迟分配，直到文件在 cache 中写完才开始分配数据块并写入磁盘，这样就能优化整个文件的数据块分配，与前两种特性搭配起来可以显著提升性能。 快速 fsck。以前执行 fsck 第一步就会很慢，因为它要检查所有的 inode，现在 Ext4 给每个组的 inode 表中都添加了一份未使用 inode 的列表，今后 fsck Ext4 文件系统就可以跳过它们而只去检查那些在用的 inode 了。 日志校验。日志是最常用的部分，也极易导致磁盘硬件故障，而从损坏的日志中恢复数据会导致更多的数据损坏。Ext4 的日志校验功能可以很方便地判断日志数据是否损坏，而且它将 Ext3 的两阶段日志机制合并成一个阶段，在增加安全性的同时提高了性能。 “无日志”（No Journaling）模式。日志总归有一些开销，Ext4 允许关闭日志，以便某些有特殊需求的用户可以借此提升性能。 在线碎片整理。尽管延迟分配. 多块分配和 extents 能有效减少文件系统碎片，但碎片还是不可避免会产生。Ext4 支持在线碎片整理，并将提供 e4defrag 工具进行个别文件或整个文件系统的碎片整理。 inode 相关特性。Ext4 支持更大的 inode，较之 Ext3 默认的 inode 大小 128 字节，Ext4 为了在 inode 中容纳更多的扩展属性（如纳秒时间戳或 inode 版本），默认 inode 大小为 256 字节。Ext4 还支持快速扩展属性（fast extended attributes）和 inode 保留（inodes reservation）。 持久预分配（Persistent preallocation）。P2P 软件为了保证下载文件有足够的空间存放，常常会预先创建一个与所下载文件大小相同的空文件，以免未来的数小时或数天之内磁盘空间不足导致下载失败。Ext4 在文件系统层面实现了持久预分配并提供相应的 API（libc 中的 posix_fallocate（）），比应用软件自己实现更有效率。 默认启用 barrier。磁盘上配有内部缓存，以便重新调整批量数据的写操作顺序，优化写入性能，因此文件系统必须在日志数据写入磁盘之后才能写 commit 记录，若 commit 记录写入在先，而日志有可能损坏，那么就会影响数据完整性。Ext4 默认启用 barrier，只有当 barrier 之前的数据全部写入磁盘，才能写 barrier 之后的数据。（可通过 “mount -o barrier=0” 命令禁用该特性。） ZFS ZFS源自于Sun Microsystems为Solaris操作系统开发的文件系统。ZFS是一个具有高存储容量. 文件系统与卷管理概念整合. 崭新的磁盘逻辑结构的轻量级文件系统，同时也是一个便捷的存储池管理系统。ZFS是一个使用CDDL协议条款授权的开源项目。 HFS 1. HFS文件系统概念 分层文件系统（Hierarchical File System，HFS）是一种由苹果电脑开发，并使用在Mac OS上的文件系统。最初被设计用于软盘和硬盘，同时也可以在在只读媒体如CD-ROM上见到。 2. HFS文件系统开发过程 HFS首次出现在1985年9月17日，作为Macintosh电脑上新的文件系统。它取代只用于早期Mac型号所使用的平面文件系统Macintosh File System（MFS）。因为Macintosh电脑所产生的数据，比其它通常的文件系统，如DOS使用的FAT或原始Unix文件系统所允许存储的数据更多。苹果电脑开发了一种新式更适用的文件系统，而不是采用现有的规格。例如，HFS允许文件名最多有31个字符的长度，支持metadata和双分支（每个文件的数据和资源支分开存储）文件。 尽管HFS象其它大多数文件系统一样被视为专有的格式，因为只有它为大多数最新的操作系统提供了很好的通用解决方法以存取HFS格式磁盘。 在1998年，苹果电脑发布了HFS Plus，其改善了HFS对磁盘空间的地址定位效率低下，并加入了其它的改进。当前版本的Mac OS仍旧支持HFS，但从Mac OS X开始HFS卷不能作为启动用。 3. 构成方式 分层文件系统把一个卷分为许多512字节的“逻辑块”。这些逻辑块被编组为“分配块”，这些分配块可以根据卷的尺寸包含一个或多个逻辑块。HFS对地址分配块使用16位数值，分配块的最高限制数量是65536。 组成一个HFS卷需要下面的五个结构： 4. 卷的逻辑块0和1是启动块，它包含了系统启动信息。例如，启动时载入的系统名称和壳（通常是Finder）文件。 5. 逻辑块2包含主目录块（Master Directory Block，简称MDB）。 6. 逻辑块3是卷位图（Volume Bitmap）的启动块，它追踪分配块使用状态。 7. 总目录文件（Catalog File）是一个包含所有文件的记录和储存在卷中目录的B*-tree。 8. 扩展溢出文件（Extent Overflow File）是当最初总目录文件中三个扩展占用后，另外一个包含额外扩展记录的分配块对应信息的B*-tree。 Linux Linux常见命令 显示文件目录命令ls 如ls 改变当前目录命令cd 如cd /home 建立子目录mkdir 如mkdir xiong 删除子目录命令rmdir 如rmdir /mnt/cdrom 删除文件命令rm 如rm /ucdos.bat 文件复制命令cp 如cp /ucdos /fox 获取帮助信息命令man 如man ls 显示文件的内容less 如less mwm.lx 重定向与管道type 如type readme&gt;&gt;direct，将文件readme的内容追加到文direct中 Linux中显示一个文件最后几行的命令是什么? tail -n 20 filename tail命令语法 tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ] 参数解释： -f 该参数用于监视File文件增长。 -c Number 从 Number 字节位置读取指定文件 -n Number 从 Number 行位置读取指定文件。 -m Number 从 Number 多字节字符位置读取指定文件，比方你的文件假设包括中文字，假设指定-c参数，可能导致截断，但使用-m则会避免该问题。 -b Number 从 Number 表示的512字节块位置读取指定文件。 -k Number 从 Number 表示的1KB块位置读取指定文件。","path":"2019/04/09/Java面试-操作系统/","date":"04-09","excerpt":"","tags":[{"name":"面试","slug":"面试","permalink":"https://jijiking51.cn/tags/面试/"},{"name":"操作系统","slug":"操作系统","permalink":"https://jijiking51.cn/tags/操作系统/"}],"preview":"http://img.jijiking51.cn/20981.jpg"},{"title":"github利用hexo搭建个人博客","text":"准备工作安装gitGitHub Windows 安装Node.JSNode.JS 确认npm命令已经配置好 安装Hexo1npm install hexo-cli -g 初始化配置Hexo创建根目录12# 创建博客根目录mkdir blogroot 初始化Hexo123456# 进入根目录cd blogroot# 初始化项目hexo init# 安装插件npm install 安装git插件安装配置安装git插件12# 安装git插件npm install hexo-deployer-git --save 修改配置文件123456# 修改根目录下的_config.ymldeploy: type: git // 上传方式 repository: //项目地址 branch: // 上传分支 message: // 上传时默认信息，如果不设置则为上传时的时间 查看效果12345678# 生成文章hexo n# 生成public静态文件hexo g# 本地预览效果hexo s# 将public静态文件上传到githubhexo d github准备创建博客仓库 创建项目 项目名为用户名.github.io 点击项目setting，下翻到GitHub Pages，设置上传的分支（与上面配置里面写的相同），并且按change theme选择主题（默认就行） 配置ssh私钥 右键git bash 123# username和email@email.com替换为自己的git config --global user.name \"username\"git config --global user.email \"email@email.com\" 生成秘钥 12# 输入后一路回车就好ssh-keygen -t rsa -C \"账户邮箱\" 输入eval &quot;$(ssh-agent -s)&quot;，添加密钥到ssh-agent。 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent。 github的个人setting中找到SSH and GPG keys，添加新的ssh，打开C:\\Users\\Administrator.ssh\\id_rsa.pub 文件，将里面的内容张贴到里面 输入ssh -T git@github.com，出现用户名则表示成功 配置个人域名 github点击settings，拉到下面Custom domain处 ，填写自己域名 本地的source中添加CNAME文件（更新博客的时候保证每次都带有这个文件），检查项目下是否出现了CNAME文件，内容是填写的域名（不要加http，www），如果没有就创建一个新的文件并填写对应内容 ping一下github分配的博客页面，得到一个IP，在自己的域名解析中，将www和@的都解析到这个IP上 坑配置好github Page后报错Page build failed: Date is not a valid datetime,这是非jekyll生成的站点，要添加.nojekyll空文件在repository的根目录下，关闭针对jekyll的检查。 方法： ​ 在github根目录下创建空文件.nojekyll,同样，我们要在source中添加这个文件 更换主题使用gal主题 获取主题 1git clone https://github.com/ZEROKISEKI/hexo-theme-gal.git themes/gal 将clone下来的文件/_source/的tags和categories文件夹拷贝到博客根目录下的source文件夹下 在博客根目录下下载对应插件 12345npm install hexo-renderer-sass --save npm install hexo-renderer-scss --savenpm install hexo-generator-json-content --save 添加内容到根目录下的_config.yml 123456789101112131415161718192021jsonContent: dateFormat: MM-DD pages: title: true text: true path: true date: true excerpt: true preview: true posts: title: true text: true path: true date: true excerpt: true tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;] preview: true 开启搜索，404，分类，标签页面 1234hexo new page \"search\" // 搜索功能的必须步骤hexo new page \"404\" // 开启404页面hexo new page \"categories\" // 开启分类页面hexo new page \"tags\" // 开启标签页面 配置分类和标签页面 12345678910111213141516171819202122232425262728293031323334# 修改根目录下的source/categories/index.md文件---title: 文章分类date: 2017-05-27 13:47:40---# 添加 type: \"categories\"---title: 文章分类date: 2017-05-27 13:47:40type: \"categories\"---# 修改根目录下source/tags/index.md文件---title: 标签date: 2017-05-27 14:22:08---# 添加type: \"tags\"---title: 文章分类date: 2017-05-27 13:47:40type: \"tags\"---# 以后写文章头部示例---title: 测试date: 2019-04-2 14:02:57categories: - demotags:- 测试标签1- 测试标签2--- 其他配置参考gal项目wiki","path":"2019/04/09/github利用hexo搭建个人博客/","date":"04-09","excerpt":"","tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://jijiking51.cn/tags/踩坑/"},{"name":"hexo","slug":"hexo","permalink":"https://jijiking51.cn/tags/hexo/"},{"name":"个人博客","slug":"个人博客","permalink":"https://jijiking51.cn/tags/个人博客/"}],"preview":"http://img.jijiking51.cn/42992.jpg"}]}